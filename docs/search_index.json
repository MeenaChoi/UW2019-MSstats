[
["index.html", "ASMS 2019: Case studies in quantitative proteomics Before we start Schedule License", " ASMS 2019: Case studies in quantitative proteomics Meena Choi and Ting Huang 2019-06-01 Before we start Download the data files here: https://drive.google.com/drive/u/2/folders/16QsY4zqkemAWWdP8afr2Qpb-UpABth8o Schedule Day Time Content 2 9:00 - 10:30am Hands-on: Intro R, data exploration and basic statistics (MC) 10:30 - 11:00am Breaks 11:00 - 12:00pm Kecture: MSstats/ MSstatsTMT (OV) 12:00 - 1:00pm Lunch break 1:00 - 2:30pm Hands-on: Differential abundance analysis in MSstats (MC) 2:30 - 3:00pm Breaks 3:00 - 4:00pm Hands-on: MSstatsOV (TH) Meena Choi (MC), Ting Huang (TH), Olga Vitek (OV) License This material, unless otherwise stated, is made available under the Creative Commons Attribution license. You are free to: Share - copy and redistribute the material in any medium or format Adapt - remix, transform, and build upon the material for any purpose, even commercially. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution - You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. No additional restrictions - You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. "],
["section-6-introductory-statistics-with-r.html", "Chapter 1 Section 6: Introductory statistics with R 1.1 Basic statistics 1.2 Statistical hypothesis test", " Chapter 1 Section 6: Introductory statistics with R Objectives Randomization and basic statistics Statistical hypothesis testing: t-test Sample size calculation Analysis for categorical data Linear regression and correlation 1.1 Basic statistics 1.1.1 Randomization 1.1.1.1 Random selection of samples from a larger set Let’s assume that we have the population with a total of 10 subjects. Suppose we label them from 1 to 10 and randomly would like to select 3 subjects we can do this using the sample function. When we run sample another time, different subjects will be selected. Try this a couple times. sample(10, 3) ## [1] 2 5 6 sample(10, 3) ## [1] 9 5 10 Now suppose we would like to select the same randomly selected samples every time, then we can use a random seed number. set.seed(3728) sample(10, 3) ## [1] 1 9 10 set.seed(3728) sample(10, 3) ## [1] 1 9 10 Let’s practice with fun example. Select two in our group member for coming early next Monday. group.member &lt;- c(&#39;Cyril&#39;, &#39;Dan&#39;, &#39;Kylie&#39;, &#39;Meena&#39;, &#39;Sara&#39;, &#39;Ting&#39;, &#39;Tsung-Heng&#39;, &#39;Tyler&#39;) sample(group.member, 2) ## [1] &quot;Ting&quot; &quot;Sara&quot; 1.1.1.2 Completely randomized order of MS runs Let’s load iprg data first. load(&#39;./data/iprg.rda&#39;) We can also create a random order using all elements of iPRG dataset. Again, we can achieve this using sample, asking for exactly the amount of samples in the subset. This time, each repetition gives us a different order of the complete set. msrun &lt;- unique(iprg$Run) msrun ## [1] &quot;JD_06232014_sample1_B.raw&quot; &quot;JD_06232014_sample1_C.raw&quot; ## [3] &quot;JD_06232014_sample1-A.raw&quot; &quot;JD_06232014_sample2_A.raw&quot; ## [5] &quot;JD_06232014_sample2_B.raw&quot; &quot;JD_06232014_sample2_C.raw&quot; ## [7] &quot;JD_06232014_sample3_A.raw&quot; &quot;JD_06232014_sample3_B.raw&quot; ## [9] &quot;JD_06232014_sample3_C.raw&quot; &quot;JD_06232014_sample4_B.raw&quot; ## [11] &quot;JD_06232014_sample4_C.raw&quot; &quot;JD_06232014_sample4-A.raw&quot; ## randomize order among all 12 MS runs sample(msrun, length(msrun)) ## [1] &quot;JD_06232014_sample4_C.raw&quot; &quot;JD_06232014_sample3_A.raw&quot; ## [3] &quot;JD_06232014_sample4-A.raw&quot; &quot;JD_06232014_sample4_B.raw&quot; ## [5] &quot;JD_06232014_sample2_C.raw&quot; &quot;JD_06232014_sample1_C.raw&quot; ## [7] &quot;JD_06232014_sample2_A.raw&quot; &quot;JD_06232014_sample3_C.raw&quot; ## [9] &quot;JD_06232014_sample3_B.raw&quot; &quot;JD_06232014_sample1-A.raw&quot; ## [11] &quot;JD_06232014_sample1_B.raw&quot; &quot;JD_06232014_sample2_B.raw&quot; ## different order will be shown. sample(msrun, length(msrun)) ## [1] &quot;JD_06232014_sample1_B.raw&quot; &quot;JD_06232014_sample3_A.raw&quot; ## [3] &quot;JD_06232014_sample1-A.raw&quot; &quot;JD_06232014_sample2_A.raw&quot; ## [5] &quot;JD_06232014_sample3_B.raw&quot; &quot;JD_06232014_sample1_C.raw&quot; ## [7] &quot;JD_06232014_sample2_B.raw&quot; &quot;JD_06232014_sample3_C.raw&quot; ## [9] &quot;JD_06232014_sample4_C.raw&quot; &quot;JD_06232014_sample4-A.raw&quot; ## [11] &quot;JD_06232014_sample2_C.raw&quot; &quot;JD_06232014_sample4_B.raw&quot; 1.1.1.3 Randomized block design Allow to remove known sources of variability that you are not interested in. Group conditions into blocks such that the conditions in a block are as similar as possible. Randomly assign samples with a block. This particular dataset contains a total of 12 MS runs across 4 conditions, 3 technical replicates per condition. Using the block.random function in the psych package, we can achieve randomized block designs! block.random function makes random assignment of n subjects with an equal number in all of N conditions. library(&quot;psych&quot;) ## load the psych package msrun &lt;- unique(iprg[, c(&#39;Condition&#39;,&#39;Run&#39;)]) msrun ## Condition Run ## 1 Condition1 JD_06232014_sample1_B.raw ## 2 Condition1 JD_06232014_sample1_C.raw ## 3 Condition1 JD_06232014_sample1-A.raw ## 4 Condition2 JD_06232014_sample2_A.raw ## 5 Condition2 JD_06232014_sample2_B.raw ## 6 Condition2 JD_06232014_sample2_C.raw ## 7 Condition3 JD_06232014_sample3_A.raw ## 8 Condition3 JD_06232014_sample3_B.raw ## 9 Condition3 JD_06232014_sample3_C.raw ## 10 Condition4 JD_06232014_sample4_B.raw ## 11 Condition4 JD_06232014_sample4_C.raw ## 12 Condition4 JD_06232014_sample4-A.raw ## 4 Conditions of 12 MS runs randomly ordered block.random(n = 12, c(Condition = 4)) ## blocks Condition ## S1 1 4 ## S2 1 1 ## S3 1 2 ## S4 1 3 ## S5 2 2 ## S6 2 4 ## S7 2 1 ## S8 2 3 ## S9 3 4 ## S10 3 1 ## S11 3 3 ## S12 3 2 block.random(n = 12, c(Condition = 4, BioReplicate=3)) ## blocks Condition BioReplicate ## S1 1 3 3 ## S2 1 1 3 ## S3 1 1 2 ## S4 1 4 2 ## S5 1 1 1 ## S6 1 3 2 ## S7 1 2 2 ## S8 1 2 3 ## S9 1 4 3 ## S10 1 2 1 ## S11 1 3 1 ## S12 1 4 1 1.1.2 Basic statistical summaries library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union 1.1.2.1 Calculate simple statistics Let’s start data with one protein as an example and calculate the mean, standard deviation, standard error of the mean across all replicates per condition. We then store all the computed statistics into a single summary data frame for easy access. We can use the aggregate function to compute summary statistics. aggregate splits the data into subsets, computes summary statistics for each, and returns the result in a convenient form. # check what proteins are in dataset, show all protein names head(unique(iprg$Protein)) ## [1] &quot;sp|D6VTK4|STE2_YEAST&quot; &quot;sp|O13297|CET1_YEAST&quot; &quot;sp|O13329|FOB1_YEAST&quot; ## [4] &quot;sp|O13539|THP2_YEAST&quot; &quot;sp|O13547|CCW14_YEAST&quot; &quot;sp|O13563|RPN13_YEAST&quot; length(unique(iprg$Protein)) ## [1] 3027 #distinct(iprg, Protein) n_distinct(iprg$Protein) ## [1] 3027 # Let&#39;s start with one protein, named &quot;sp|P44015|VAC2_YEAST&quot; oneproteindata &lt;- iprg[iprg$Protein == &quot;sp|P44015|VAC2_YEAST&quot;, ] # there are 12 rows in oneproteindata oneproteindata ## # A tibble: 12 x 7 ## Protein Log2Intensity Run Condition BioReplicate Intensity ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 sp|P44… 26.3 JD_0… Conditio… 1 82714388. ## 2 sp|P44… 26.1 JD_0… Conditio… 1 72749239. ## 3 sp|P44… 26.3 JD_0… Conditio… 1 82100518. ## 4 sp|P44… 25.8 JD_0… Conditio… 2 59219741. ## 5 sp|P44… 26.1 JD_0… Conditio… 2 72690802. ## 6 sp|P44… 26.1 JD_0… Conditio… 2 71180513. ## 7 sp|P44… 23.1 JD_0… Conditio… 3 9295260. ## 8 sp|P44… 23.3 JD_0… Conditio… 3 10505591. ## 9 sp|P44… 23.3 JD_0… Conditio… 3 10295788. ## 10 sp|P44… 20.9 JD_0… Conditio… 4 2019205. ## 11 sp|P44… 21.7 JD_0… Conditio… 4 3440629. ## 12 sp|P44… 20.3 JD_0… Conditio… 4 1248781. ## # … with 1 more variable: TechReplicate &lt;chr&gt; # with dplyr oneproteindata.bcp &lt;- filter(iprg, Protein == &quot;sp|P44015|VAC2_YEAST&quot;) oneproteindata.bcp ## # A tibble: 12 x 7 ## Protein Log2Intensity Run Condition BioReplicate Intensity ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 sp|P44… 26.3 JD_0… Conditio… 1 82714388. ## 2 sp|P44… 26.1 JD_0… Conditio… 1 72749239. ## 3 sp|P44… 26.3 JD_0… Conditio… 1 82100518. ## 4 sp|P44… 25.8 JD_0… Conditio… 2 59219741. ## 5 sp|P44… 26.1 JD_0… Conditio… 2 72690802. ## 6 sp|P44… 26.1 JD_0… Conditio… 2 71180513. ## 7 sp|P44… 23.1 JD_0… Conditio… 3 9295260. ## 8 sp|P44… 23.3 JD_0… Conditio… 3 10505591. ## 9 sp|P44… 23.3 JD_0… Conditio… 3 10295788. ## 10 sp|P44… 20.9 JD_0… Conditio… 4 2019205. ## 11 sp|P44… 21.7 JD_0… Conditio… 4 3440629. ## 12 sp|P44… 20.3 JD_0… Conditio… 4 1248781. ## # … with 1 more variable: TechReplicate &lt;chr&gt; # If you want to see more details, ?aggregate 1.1.2.2 Calculate mean per groups ## splits &#39;oneproteindata&#39; into subsets by &#39;Condition&#39;, ## then, compute &#39;FUN=mean&#39; of &#39;log2Int&#39; sub.mean &lt;- aggregate(Log2Intensity ~ Condition, data = oneproteindata, FUN = mean) sub.mean ## Condition Log2Intensity ## 1 Condition1 26.23632 ## 2 Condition2 26.00661 ## 3 Condition3 23.25609 ## 4 Condition4 20.97056 # with dplyr sub.mean.bcp &lt;- oneproteindata %&gt;% group_by(Condition) %&gt;% summarise(mean=mean(Log2Intensity)) sub.mean.bcp ## # A tibble: 4 x 2 ## Condition mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 Condition1 26.2 ## 2 Condition2 26.0 ## 3 Condition3 23.3 ## 4 Condition4 21.0 1.1.2.3 Calculate SD (standard deviation) per groups \\[ s = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^n (x_i - \\bar x)^2} \\] Challenge Using the aggregate function above, calculate the standard deviation, by applying the median function. ## The same as mean calculation above. &#39;FUN&#39; is changed to &#39;sd&#39;. sub.median &lt;- aggregate(Log2Intensity ~ Condition, data = oneproteindata, FUN = median) sub.median ## Condition Log2Intensity ## 1 Condition1 26.29089 ## 2 Condition2 26.08498 ## 3 Condition3 23.29555 ## 4 Condition4 20.94536 # with dplyr sub.median.bcp &lt;- oneproteindata %&gt;% group_by(Condition) %&gt;% summarise(median=median(Log2Intensity)) sub.median.bcp ## # A tibble: 4 x 2 ## Condition median ## &lt;chr&gt; &lt;dbl&gt; ## 1 Condition1 26.3 ## 2 Condition2 26.1 ## 3 Condition3 23.3 ## 4 Condition4 20.9 Using the aggregate function above, calculate the standard deviation, by applying the sd function. ## The same as mean calculation above. &#39;FUN&#39; is changed to &#39;sd&#39;. sub.sd &lt;- aggregate(Log2Intensity ~ Condition, data = oneproteindata, FUN = sd) sub.sd ## Condition Log2Intensity ## 1 Condition1 0.10396539 ## 2 Condition2 0.16268179 ## 3 Condition3 0.09467798 ## 4 Condition4 0.73140174 # with dplyr sub.sd.bcp &lt;- oneproteindata %&gt;% group_by(Condition) %&gt;% summarise(sd = sd(Log2Intensity)) sub.sd.bcp ## # A tibble: 4 x 2 ## Condition sd ## &lt;chr&gt; &lt;dbl&gt; ## 1 Condition1 0.104 ## 2 Condition2 0.163 ## 3 Condition3 0.0947 ## 4 Condition4 0.731 1.1.2.4 Count the number of observation per groups Challenge Using the aggregate function above, count the number of observations per group with the length function. ## The same as mean calculation. &#39;FUN&#39; is changed &#39;length&#39;. sub.len &lt;- aggregate(Log2Intensity ~ Condition, data = oneproteindata, FUN = length) sub.len ## Condition Log2Intensity ## 1 Condition1 3 ## 2 Condition2 3 ## 3 Condition3 3 ## 4 Condition4 3 # with dplyr sub.len.bcp &lt;- oneproteindata %&gt;% group_by(Condition) %&gt;% summarise(count = n()) sub.len.bcp ## # A tibble: 4 x 2 ## Condition count ## &lt;chr&gt; &lt;int&gt; ## 1 Condition1 3 ## 2 Condition2 3 ## 3 Condition3 3 ## 4 Condition4 3 1.1.2.5 Calculate SE (standard error of mean) per groups \\[ SE = \\sqrt{\\frac{s^2}{n}} \\] sub.se &lt;- sqrt(sub.sd$Log2Intensity^2 / sub.len$Log2Intensity) sub.se ## [1] 0.06002444 0.09392438 0.05466236 0.42227499 We can now make the summary table including the results above (mean, sd, se and length). ## paste0 : concatenate vectors after convering to character. (grp &lt;- paste0(&quot;Condition&quot;, 1:4)) ## [1] &quot;Condition1&quot; &quot;Condition2&quot; &quot;Condition3&quot; &quot;Condition4&quot; ## It is equivalent to paste(&quot;Condition&quot;, 1:4, sep=&quot;&quot;) summaryresult &lt;- data.frame(Group = grp, mean = sub.mean$Log2Intensity, sd = sub.sd$Log2Intensity, se = sub.se, length = sub.len$Log2Intensity) summaryresult ## Group mean sd se length ## 1 Condition1 26.23632 0.10396539 0.06002444 3 ## 2 Condition2 26.00661 0.16268179 0.09392438 3 ## 3 Condition3 23.25609 0.09467798 0.05466236 3 ## 4 Condition4 20.97056 0.73140174 0.42227499 3 Challenge Make the same table as summaryresult with dplyr package. summaryresult.dplyr &lt;- oneproteindata %&gt;% group_by(Condition) %&gt;% summarise(mean = mean(Log2Intensity), sd = sd(Log2Intensity), length = n()) summaryresult.dplyr &lt;- mutate(summaryresult.dplyr, se=sqrt(sd^2 / length)) summaryresult.dplyr ## # A tibble: 4 x 5 ## Condition mean sd length se ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Condition1 26.2 0.104 3 0.0600 ## 2 Condition2 26.0 0.163 3 0.0939 ## 3 Condition3 23.3 0.0947 3 0.0547 ## 4 Condition4 21.0 0.731 3 0.422 1.1.3 Visualization with error bars for descriptive purpose error bars can have a variety of meanings or conclusions if what they represent is not precisely specified. Below we provide some examples of which types of error bars are common. We’re using the summary of protein sp|P44015|VAC2_YEAST from the previous section and the ggplot2 package as it provides a convenient way to make easily adaptable plots. library(ggplot2) ## Registered S3 methods overwritten by &#39;ggplot2&#39;: ## method from ## [.quosures rlang ## c.quosures rlang ## print.quosures rlang ## ## Attaching package: &#39;ggplot2&#39; ## The following objects are masked from &#39;package:psych&#39;: ## ## %+%, alpha # means without any errorbar p &lt;- ggplot(aes(x = Group, y = mean, colour = Group), data = summaryresult)+ geom_point(size = 3) p Let’s change a number of visual properties to make the plot more attractive. Let’s change the labels of x-axis and y-axis and title: labs(title=&quot;Mean&quot;, x=&quot;Condition&quot;, y='Log2(Intensity)') Let’s change background color for white: theme_bw() Let’s change size or color of labels of axes and title, text of x-axis by using a theme Let’s change the position of legend (use 'none' to remove it) Let’s make the box for legend Let’s remove the box for legend key. See also this post for options of theme, post for complete theme. p2 &lt;- p + labs(title = &quot;Mean&quot;, x = &quot;Group&quot;, y = &#39;Log2(Intensity)&#39;) + theme_bw() + theme(plot.title = element_text(size = 25, colour = &quot;darkblue&quot;), axis.title.x = element_text(size = 15), axis.title.y = element_text(size = 15), axis.text.x = element_text(size = 13), legend.position = &#39;bottom&#39;, legend.background = element_rect(colour = &#39;black&#39;), legend.key = element_rect(colour = &#39;white&#39;)) p2 Let’s now add the standard deviation: # mean with SD p2 + geom_errorbar(aes(ymax = mean + sd, ymin = mean - sd), width = 0.1) + labs(title=&quot;Mean with SD&quot;) Challenge Add the standard error of the mean. Which one is smaller? # mean with SE p2 + geom_errorbar(aes(ymax = mean + se, ymin=mean - se), width = 0.1) + labs(title=&quot;Mean with SE&quot;) ## The SE is narrow than the SD! Challenge Add the standard error of the mean with black color. # mean with SE p2 + geom_errorbar(aes(ymax = mean + se, ymin=mean - se), width = 0.1, color=&#39;black&#39;) + labs(title=&quot;Mean with SE&quot;) 1.1.4 Working with statistical distributions For each statistical distribution, we have function to compute density distribution function quantile function random generation For the normale distribution norm, these are respectively dnorm pnorm qnorm rnorm Let’s start by sampling 1000000 values from a normal distribution \\(N(0, 1)\\): xn &lt;- rnorm(1e6) hist(xn, freq = FALSE) rug(xn) lines(density(xn), lwd = 2) By definition, the area under the density curve is 1. The area at the left of 0, 1, and 2 are respectively: pnorm(0) ## [1] 0.5 pnorm(1) ## [1] 0.8413447 pnorm(2) ## [1] 0.9772499 To ask the inverse question, we use the quantile function. The obtain 0.5, 0.8413447 and 0.9772499 of our distribution, we need means of: qnorm(0.5) ## [1] 0 qnorm(pnorm(1)) ## [1] 1 qnorm(pnorm(2)) ## [1] 2 qnorm(0.05) ## [1] -1.644854 Finally, the density function gives us the height at which we are for a given mean: hist(xn, freq = FALSE) lines(density(xn), lwd = 2) points(0, dnorm(0), pch = 19, col = &quot;red&quot;) points(1, dnorm(1), pch = 1, col = &quot;blue&quot;) points(2, dnorm(2), pch = 4, col = &quot;orange&quot;) 1.1.5 Calculate the confidence interval Now that we’ve covered the standard error of the mean and the standard deviation, let’s investigate how we can add custom confidence intervals (CI) for our measurement of the mean. We’ll add these CI’s to the summary results we previously stored for protein sp|P44015|VAC2_YEAST. Confidence interval: \\[\\mbox{mean} \\pm (SE \\times \\frac{\\alpha}{2} ~ \\mbox{quantile of t distribution})\\] To calculate the 95% confident interval, we need to be careful and set the quantile for two-sided. We need to divide by two for error. For example, 95% confidence interval, right tail is 2.5% and left tail is 2.5%. summaryresult$ciw.lower.95 &lt;- summaryresult$mean - qt(0.975, summaryresult$len - 1) * summaryresult$se summaryresult$ciw.upper.95 &lt;- summaryresult$mean + qt(0.975, summaryresult$len - 1) * summaryresult$se summaryresult ## Group mean sd se length ciw.lower.95 ## 1 Condition1 26.23632 0.10396539 0.06002444 3 25.97805 ## 2 Condition2 26.00661 0.16268179 0.09392438 3 25.60248 ## 3 Condition3 23.25609 0.09467798 0.05466236 3 23.02090 ## 4 Condition4 20.97056 0.73140174 0.42227499 3 19.15366 ## ciw.upper.95 ## 1 26.49458 ## 2 26.41073 ## 3 23.49128 ## 4 22.78746 summaryresult.dplyr %&gt;% mutate(ciw.lower.95 = mean - qt(0.975, length-1)*se, ciw.upper.95 = mean + qt(0.975, length-1)*se) ## # A tibble: 4 x 7 ## Condition mean sd length se ciw.lower.95 ciw.upper.95 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Condition1 26.2 0.104 3 0.0600 26.0 26.5 ## 2 Condition2 26.0 0.163 3 0.0939 25.6 26.4 ## 3 Condition3 23.3 0.0947 3 0.0547 23.0 23.5 ## 4 Condition4 21.0 0.731 3 0.422 19.2 22.8 summaryresult.dplyr ## # A tibble: 4 x 5 ## Condition mean sd length se ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Condition1 26.2 0.104 3 0.0600 ## 2 Condition2 26.0 0.163 3 0.0939 ## 3 Condition3 23.3 0.0947 3 0.0547 ## 4 Condition4 21.0 0.731 3 0.422 # mean with 95% two-sided confidence interval ggplot(aes(x = Group, y = mean, colour = Group), data = summaryresult) + geom_point() + geom_errorbar(aes(ymax = ciw.upper.95, ymin = ciw.lower.95), width = 0.1) + labs(title=&quot;Mean with 95% confidence interval&quot;, x=&quot;Condition&quot;, y=&#39;Log2(Intensity)&#39;) + theme_bw() + theme(plot.title = element_text(size=25, colour=&quot;darkblue&quot;), axis.title.x = element_text(size=15), axis.title.y = element_text(size=15), axis.text.x = element_text(size=13), legend.position = &#39;bottom&#39;, legend.background = element_rect(colour = &#39;black&#39;), legend.key = element_rect(colour=&#39;white&#39;)) Challenges Replicate the above for the 99% two-sided confidence interval. # mean with 99% two-sided confidence interval summaryresult$ciw.lower.99 &lt;- summaryresult$mean - qt(0.995,summaryresult$len-1) * summaryresult$se summaryresult$ciw.upper.99 &lt;- summaryresult$mean + qt(0.995,summaryresult$len-1) * summaryresult$se summaryresult ## Group mean sd se length ciw.lower.95 ## 1 Condition1 26.23632 0.10396539 0.06002444 3 25.97805 ## 2 Condition2 26.00661 0.16268179 0.09392438 3 25.60248 ## 3 Condition3 23.25609 0.09467798 0.05466236 3 23.02090 ## 4 Condition4 20.97056 0.73140174 0.42227499 3 19.15366 ## ciw.upper.95 ciw.lower.99 ciw.upper.99 ## 1 26.49458 25.64058 26.83205 ## 2 26.41073 25.07442 26.93879 ## 3 23.49128 22.71357 23.79860 ## 4 22.78746 16.77955 25.16157 ggplot(aes(x = Group, y = mean, colour = Group), data = summaryresult) + geom_point() + geom_errorbar(aes(ymax = ciw.upper.99, ymin=ciw.lower.99), width=0.1) + labs(title=&quot;Mean with 99% confidence interval&quot;, x=&quot;Condition&quot;, y=&#39;Log2(Intensity)&#39;) + theme_bw()+ theme(plot.title = element_text(size=25, colour=&quot;darkblue&quot;), axis.title.x = element_text(size=15), axis.title.y = element_text(size=15), axis.text.x = element_text(size=13), legend.position = &#39;bottom&#39;, legend.background = element_rect(colour=&#39;black&#39;), legend.key = element_rect(colour=&#39;white&#39;)) Some comments Error bars with SD and CI are overlapping between groups! Error bars for the SD show the spread of the population while error bars based on SE reflect the uncertainty in the mean and depend on the sample size. Confidence intervals of n on the other hand mean that the intervals capture the population mean n percent of the time. When the sample size increases, CI and SE are getting closer to each other. 1.1.6 Saving our results We have two objects that contain all the information that we have generated so far: The summaryresults and summaryresults.dplyr objects, that contains all the summary statistics. save(summaryresult, file = &quot;./data/summaryresults.rda&quot;) save(summaryresult.dplyr, file = &quot;./data/summaryresults.dplyr.rda&quot;) We can also save the summary result as a csv file using the write.csv function: write.csv(sumamryresult, file = &quot;./data/summary.csv&quot;) Tip: Exporting to csv is useful to share your work with collaborators that do not use R, but for many continous work in R, to assure data validity accords platforms, the best format is rda. 1.2 Statistical hypothesis test First, we are going to prepare the session for further analyses. load(&quot;./data/summaryresults.rda&quot;) load(&quot;./data/iprg.rda&quot;) 1.2.1 Two sample t-test for one protein with one feature Now, we’ll perform a t-test whether protein sp|P44015|VAC2_YEAST has a change in abundance between Condition 1 and Condition 2. Hypothesis \\(H_0\\): no change in abundance, mean(Condition1) - mean(Condition2) = 0 \\(H_a\\): change in abundance, mean(Condition1) - mean(Condition 2) \\(\\neq\\) 0 Statistics Observed \\(t = \\frac{\\mbox{difference of group means}}{\\mbox{estimate of variation}} = \\frac{(mean_{1} - mean_{2})}{SE} \\sim t_{\\alpha/2, df}\\) Standard error, \\(SE=\\sqrt{\\frac{s_{1}^2}{n_{1}} + \\frac{s_{2}^2}{n_{2}}}\\) with \\(n_{i}\\): number of replicates \\(s_{i}^2 = \\frac{1}{n_{i}-1} \\sum (Y_{ij} - \\bar{Y_{i \\cdot}})^2\\): sample variance Data preparation ## Let&#39;s start with one protein, named &quot;sp|P44015|VAC2_YEAST&quot; oneproteindata &lt;- iprg[iprg$Protein == &quot;sp|P44015|VAC2_YEAST&quot;, ] ## Then, get two conditions only, because t.test only works for two groups (conditions). oneproteindata.condition12 &lt;- oneproteindata[oneproteindata$Condition %in% c(&#39;Condition1&#39;, &#39;Condition2&#39;), ] oneproteindata.condition12 ## # A tibble: 6 x 7 ## Protein Log2Intensity Run Condition BioReplicate Intensity ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 sp|P44… 26.3 JD_0… Conditio… 1 82714388. ## 2 sp|P44… 26.1 JD_0… Conditio… 1 72749239. ## 3 sp|P44… 26.3 JD_0… Conditio… 1 82100518. ## 4 sp|P44… 25.8 JD_0… Conditio… 2 59219741. ## 5 sp|P44… 26.1 JD_0… Conditio… 2 72690802. ## 6 sp|P44… 26.1 JD_0… Conditio… 2 71180513. ## # … with 1 more variable: TechReplicate &lt;chr&gt; table(oneproteindata.condition12[, c(&quot;Condition&quot;, &quot;BioReplicate&quot;)]) ## BioReplicate ## Condition 1 2 ## Condition1 3 0 ## Condition2 0 3 ## with dplyr ## Let&#39;s start with one protein, named &quot;sp|P44015|VAC2_YEAST&quot; oneproteindata &lt;- filter(iprg, Protein == &quot;sp|P44015|VAC2_YEAST&quot;) ## Then, get two conditions only, because t.test only works for two groups (conditions). oneproteindata.subset &lt;- filter(oneproteindata, Condition %in% c(&#39;Condition1&#39;, &#39;Condition2&#39;)) oneproteindata.subset ## # A tibble: 6 x 7 ## Protein Log2Intensity Run Condition BioReplicate Intensity ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 sp|P44… 26.3 JD_0… Conditio… 1 82714388. ## 2 sp|P44… 26.1 JD_0… Conditio… 1 72749239. ## 3 sp|P44… 26.3 JD_0… Conditio… 1 82100518. ## 4 sp|P44… 25.8 JD_0… Conditio… 2 59219741. ## 5 sp|P44… 26.1 JD_0… Conditio… 2 72690802. ## 6 sp|P44… 26.1 JD_0… Conditio… 2 71180513. ## # … with 1 more variable: TechReplicate &lt;chr&gt; table(oneproteindata.subset[, c(&quot;Condition&quot;, &quot;BioReplicate&quot;)]) ## BioReplicate ## Condition 1 2 ## Condition1 3 0 ## Condition2 0 3 If we want to remove the levels that are not relevant anymore, we can use droplevels: oneproteindata.subset &lt;- droplevels(oneproteindata.subset) table(oneproteindata.subset[, c(&quot;Condition&quot;, &quot;BioReplicate&quot;)]) ## BioReplicate ## Condition 1 2 ## Condition1 3 0 ## Condition2 0 3 To perform the t-test, we use the t.test function. Let’s first familiarise ourselves with it by looking that the manual ?t.test And now apply to to our data # t test for different abundance (log2Int) between Groups (Condition) result &lt;- t.test(Log2Intensity ~ Condition, data = oneproteindata.subset, var.equal = FALSE) result ## ## Welch Two Sample t-test ## ## data: Log2Intensity by Condition ## t = 2.0608, df = 3.4001, p-value = 0.1206 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -0.1025408 0.5619598 ## sample estimates: ## mean in group Condition1 mean in group Condition2 ## 26.23632 26.00661 Challenge Repeat the t-test above but with calculating a 90% confidence interval for the log2 fold change. 1.2.2 The htest class The t.test function, like other hypothesis testing function, return a result of a type we haven’t encountered yet, the htest class: class(result) ## [1] &quot;htest&quot; which stores typical results from such tests. Let’s have a more detailed look at what information we can learn from the results our t-test. When we type the name of our result object, we get a short textual summary, but the object contains more details: names(result) ## [1] &quot;statistic&quot; &quot;parameter&quot; &quot;p.value&quot; &quot;conf.int&quot; &quot;estimate&quot; ## [6] &quot;null.value&quot; &quot;stderr&quot; &quot;alternative&quot; &quot;method&quot; &quot;data.name&quot; and we can access each of these by using the $ operator, like we used to access a single column from a data.frame, but the htest class is not a data.frame (it’s actually a list). For example, to access the group means, we would use result$estimate ## mean in group Condition1 mean in group Condition2 ## 26.23632 26.00661 Challenge Calculate the (log2-transformed) fold change between groups Extract the value of the t-statistics Calculate the standard error (fold-change/t-statistics) Extract the degrees of freedom (parameter) Extract the p values Extract the 95% confidence intervals We can also manually compute our t-test statistic using the formulas we descibed above and compare it with the summaryresult. Recall the summaryresult we generated last section. summaryresult ## Group mean sd se length ciw.lower.95 ## 1 Condition1 26.23632 0.10396539 0.06002444 3 25.97805 ## 2 Condition2 26.00661 0.16268179 0.09392438 3 25.60248 ## 3 Condition3 23.25609 0.09467798 0.05466236 3 23.02090 ## 4 Condition4 20.97056 0.73140174 0.42227499 3 19.15366 ## ciw.upper.95 ciw.lower.99 ciw.upper.99 ## 1 26.49458 25.64058 26.83205 ## 2 26.41073 25.07442 26.93879 ## 3 23.49128 22.71357 23.79860 ## 4 22.78746 16.77955 25.16157 summaryresult12 &lt;- summaryresult[1:2, ] ## test statistic, It is the same as &#39;result$statistic&#39; above. diff(summaryresult12$mean) ## different sign, but absolute values are same as result$estimate[1]-result$estimate[2] ## [1] -0.2297095 sqrt(sum(summaryresult12$sd^2/summaryresult12$length)) ## same as stand error ## [1] 0.1114662 ## the t-statistic : sign is different diff(summaryresult12$mean)/sqrt(sum(summaryresult12$sd^2/summaryresult12$length)) ## [1] -2.060799 1.2.3 Re-calculating the p values Referring back to our t-test results above, we can manually calculate the one- and two-side tests p-values using the t-statistics and the test parameter (using the pt function). Our result t statistic was 2.0607988 (accessible with result$statistic). Let’s start by visualising it along a t distribution. Let’s create data from such a distribution, making sure we set to appropriate parameter. ## generate 10^5 number with the same degree of freedom for distribution. xt &lt;- rt(1e5, result$parameter) plot(density(xt), xlim = c(-10, 10)) abline(v = result$statistic, col = &quot;red&quot;) ## where t statistics are located. abline(h = 0, col = &quot;gray&quot;) ## horizontal line at 0 The area on the left of that point is given by pt(result$statistic, result$parameter), which is 0.939693. The p-value for a one-sided test, which is ** the area on the right** of red line, is this given by 1 - pt(result$statistic, result$parameter) ## t ## 0.06030697 And the p-value for a two-sided test is 2 * (1 - pt(result$statistic, result$parameter)) ## t ## 0.1206139 which is the same as the one calculated by the t-test. 1.2.4 Choosing a model The decision of which statistical model is appropriate for a given set of observations depends on the type of data that have been collected. Quantitative response with quantitative predictors : regression model Categorical response with quantitative predictors : logistic regression model for bivariate categorical response (e.g., Yes/No, dead/alive), multivariate logistic regression model when the response variable has more than two possible values. Quantitative response with categorical predictors : ANOVA model (quantitative response across several populations defined by one or more categorical predictor variables) Categorical response with categorical predictors : contingency table that can be used to draw conclusions about the relationships between variables. See also Bremer &amp; Doerge, Using R at the Bench : Step-by-Step Data Analytics for Biologists, cold Spring Harbor LaboratoryPress, 2015. "],
["section-8-msstats.html", "Chapter 2 Section 8 : MSstats 2.1 introduction to data and preprocessing 2.2 Data processing - Normalization and run summarization 2.3 Differential abundance and sample size calculation", " Chapter 2 Section 8 : MSstats 2.1 introduction to data and preprocessing 2.1.1 Objective Preprocessing steps to make required input format for MSstats from output from diverse output of spectral processing tools. Make annotation file, based on experimental design. 2.1.2 Workflow in MSstats 2.1.3 Data the quantified peak intensities data from ABRF 2015, processed by Skyline. Summary of the ABRF 2015 study design, Choi, et al. J Proteome Res. 2017 2.1.4 Load MSstats Load MSstats first. Then you are ready to start MSstats. library(MSstats) ?MSstats 2.1.5 Allowable data formats MSstats performs statistical analysis steps, that follow peak identification and quantitation. Therefore, input to MSstats is the output of other software tools (such as Skyline, MaxQuant and so on) that read raw spectral files , identify and quantify spectral peaks. The preferred structure of data for use in MSstats is a .csv file in a long format with at least 10 columns representing the following variables: ProteinName, PeptideSequence, PrecursorCharge, FragmentIon, ProductCharge, IsotopeLabelType, Condition, BioReplicate, Run, Intensity. The variable names are fixed, but are case-insensitive. ## ProteinName PeptideSequence PrecursorCharge FragmentIon ProductCharge ## 1 bovine S.PVDIDTK_5 5 NA NA ## 2 bovine S.PVDIDTK_5 5 NA NA ## 3 bovine S.PVDIDTK_5 5 NA NA ## 4 bovine S.PVDIDTK_5 5 NA NA ## 5 bovine S.PVDIDTK_5 5 NA NA ## 6 bovine S.PVDIDTK_5 5 NA NA ## IsotopeLabelType Condition BioReplicate Run Intensity ## 1 L C1 1 1 2636792 ## 2 L C1 1 2 1992418 ## 3 L C1 1 3 1982146 ## 4 L C2 1 4 5019594 ## 5 L C2 1 5 4560468 ## 6 L C2 1 6 3627849 2.1.6 Convert to MSstats required format (Data cleaning) Let’s start preprocessing steps to make required input format for MSstats from output from diverse output of spectral processing tools. Data input support for various data acquisition methods : DDA, DIA, SRM Interoperability with existing computational tools : - Converter functions for 7 data processin tools : SkylinetoMSstatsFormat, MaxQtoMSstatsFormat, OpenMStoMSstatsFormat, ProgenesistoMSstatsFormat, PDtoMSstatsFormat, SpectronauttoMSstatsFormat, OpenSWATHtoMSstatsFormat, DIAUmpiretoMSstatsFormat - Consistent data cleaning steps across converter functions : filter multiple measurements, shared peptides, etc. - Generate the same format of data from diverse type of data format. 2.1.6.1 Skyline output 2.1.6.1.1 Read data The required input data is generated automatically when using MSstats report format in Skyline. We first load and access the dataset processed by Skyline. The name of saved file from Skyline using MSstats report format is ‘ABRF2015_Skyline_report.csv’. or you can use the published data from this link (https://panoramaweb.org/labkey/project/MacCoss/brendan/manuscripts/iPRG%202015/begin.view). This example dataset is the exactly same data in ‘iPRG_10ppm_2rt_15cut_nosingle.csv’ from the link above. # Read output from skyline raw.skyline &lt;- read.csv(file=&quot;data/data_Skyline/ABRF2015_Skyline_report.csv&quot;) # Check the first 6 rows of dataset head(raw.skyline) ## ProteinName PeptideSequence PeptideModifiedSequence ## 1 DECOY_sp|P0CF18|YM085_YEAST KDMYGNPFQK KDM[+16]YGNPFQK ## 2 DECOY_sp|P0CF18|YM085_YEAST KDMYGNPFQK KDM[+16]YGNPFQK ## 3 DECOY_sp|P0CF18|YM085_YEAST KDMYGNPFQK KDM[+16]YGNPFQK ## 4 DECOY_sp|P0CF18|YM085_YEAST KDMYGNPFQK KDM[+16]YGNPFQK ## 5 DECOY_sp|P0CF18|YM085_YEAST KDMYGNPFQK KDM[+16]YGNPFQK ## 6 DECOY_sp|P0CF18|YM085_YEAST KDMYGNPFQK KDM[+16]YGNPFQK ## PrecursorCharge PrecursorMz FragmentIon ProductCharge ProductMz ## 1 3 415.1974 precursor 3 415.1974 ## 2 3 415.1974 precursor 3 415.1974 ## 3 3 415.1974 precursor 3 415.1974 ## 4 3 415.1974 precursor 3 415.1974 ## 5 3 415.1974 precursor 3 415.1974 ## 6 3 415.1974 precursor 3 415.1974 ## IsotopeLabelType Condition BioReplicate FileName ## 1 light NA NA JD_06232014_sample1_B.raw ## 2 light NA NA JD_06232014_sample1_C.raw ## 3 light NA NA JD_06232014_sample1-A.raw ## 4 light NA NA JD_06232014_sample2_A.raw ## 5 light NA NA JD_06232014_sample2_B.raw ## 6 light NA NA JD_06232014_sample2_C.raw ## Area StandardType Truncated annotation_QValue ## 1 147327 NA False NA ## 2 1373397 NA False NA ## 3 71765 NA False NA ## 4 66387 NA False NA ## 5 107736 NA False NA ## 6 380812 NA False NA There are some column named differently than required input. The information for Condition and BioReplicate is missing. Let’s do preliminary check for this input. # total number of unique protein name length(unique(raw.skyline$Protein)) ## [1] 3097 # several isotopic peaks for peptide charge unique(raw.skyline$FragmentIon) ## [1] precursor precursor [M+1] precursor [M+2] ## Levels: precursor precursor [M+1] precursor [M+2] # unique FileName, which is MS run. unique(raw.skyline$FileName) ## [1] JD_06232014_sample1_B.raw JD_06232014_sample1_C.raw ## [3] JD_06232014_sample1-A.raw JD_06232014_sample2_A.raw ## [5] JD_06232014_sample2_B.raw JD_06232014_sample2_C.raw ## [7] JD_06232014_sample3_A.raw JD_06232014_sample3_B.raw ## [9] JD_06232014_sample3_C.raw JD_06232014_sample4_B.raw ## [11] JD_06232014_sample4_C.raw JD_06232014_sample4-A.raw ## 12 Levels: JD_06232014_sample1_B.raw ... JD_06232014_sample4-A.raw # &#39;Truncated&#39; column unique(raw.skyline$Truncated) ## [1] False True ## Levels: False True # count table for &#39;Truncated&#39; column xtabs(~Truncated, raw.skyline) ## Truncated ## False True ## 237 1256666 829 # count which &#39;Truncated&#39; is &#39;True&#39; sum(raw.skyline$Truncated == &#39;True&#39;) ## [1] 829 2.1.6.1.2 Set annotation file Annotation information is required to fill in Condition and BioReplicate for corresponding Run information. Users have to prepare as csv or txt file like ‘ABRF2015_Skyline_annotation.csv’, which includes Run, Condition, and BioReplicate information, and load it in R. annot.skyline &lt;- read.csv(file=&quot;data/data_Skyline/ABRF2015_Skyline_annotation.csv&quot;) annot.skyline ## Run Condition BioReplicate ## 1 JD_06232014_sample1-A.raw Condition1 1 ## 2 JD_06232014_sample2_A.raw Condition2 2 ## 3 JD_06232014_sample4_B.raw Condition4 4 ## 4 JD_06232014_sample1_B.raw Condition1 1 ## 5 JD_06232014_sample1_C.raw Condition1 1 ## 6 JD_06232014_sample2_B.raw Condition2 2 ## 7 JD_06232014_sample2_C.raw Condition2 2 ## 8 JD_06232014_sample3_A.raw Condition3 3 ## 9 JD_06232014_sample3_B.raw Condition3 3 ## 10 JD_06232014_sample3_C.raw Condition3 3 ## 11 JD_06232014_sample4-A.raw Condition4 4 ## 12 JD_06232014_sample4_C.raw Condition4 4 2.1.6.1.2.1 Common mistake for annotation file : Incorrect Run information Raw file name in the output of spectral processing tool is commonly long. We can make a typo in annotation file. If Raw file name and Run information are not matched, Let’s check whether Run information is same as File.Name in output of Skyline. setdiff(unique(raw.skyline$FileName), annot.skyline$Run) ## character(0) setdiff(annot.skyline$Run, unique(raw.skyline$FileName)) ## character(0) There is no issue in this annotation. Let’s try the example with unmatched information. annot.wrong &lt;- read.csv(file=&quot;data/data_Skyline/ABRF2015_Skyline_annotation_wrong_example.csv&quot;) annot.wrong ## Run Condition BioReplicate ## 1 JD_06232014_sample1_A.raw Condition1 1 ## 2 JD_06232014_sample2_A.raw Condition2 2 ## 3 JD_06232014_sample4_B.raw Condition4 4 ## 4 JD_06232014_sample1_B.raw Condition1 1 ## 5 JD_06232014_sample1_C.raw Condition1 1 ## 6 JD_06232014_sample2_B.raw Condition2 2 ## 7 JD_06232014_sample2_C.raw Condition2 2 ## 8 JD_06232014_sample3_A.raw Condition3 3 ## 9 JD_06232014_sample3_B.raw Condition3 3 ## 10 JD_06232014_sample3_C.raw Condition3 3 ## 11 JD_06232014_sample4-A.raw Condition4 4 ## 12 JD_06232014_sample4_C.raw Condition4 4 Note! small details : hyphen vs underline. 2.1.6.1.2.2 Common mistake for annotation file : Incorrect BioReplicate information MSstats distinguish the design of experiment as group comparison, time course, paired design, with the combination of Condition, BioReplicate, and Run. 2.1.6.1.2.3 Group comparison In a group comparison design, the conditions (e.g., disease states) are profiled across non-overlapping sets of biological replicates (i.e., subjects). In this example there are 2 conditions, Disease and Control (in general the number of conditions can vary). There are 3 subjects (i.e., biological replicates) per condition (in general an equal number of replicates per condition is not required). Overall, in this example there are 2 × 3 = 6 mass spectrometry runs. The most important is that 1) subject IDs for disease group are completely different thatn subject IDs for control group 2) Run is not order of spectral acquisition, but just unique MS run ID. In addition, if each subject has e technical replicate runs (in general technical replicates are not required, and their number per sample may vary). there are 2 × 3 × 3 = 18 mass spectrometry runs. 2.1.6.1.2.4 Time course The important feature of a time course experimental design is that a same subject (i.e., biological replicate) is repetitively measured across multiple time points. In this example there are 3 time points, Time1, Time2, and Time3 (in general the number of times can vary). There are 3 subjects (i.e., biological replicates) measured across times (in general an equal number of times per replicate is not required). There are no technical replicates (in general the number of technical replicates per sample may vary). Overall, in this example there are 3 × 3 = 9 mass spectrometry runs. 2.1.6.1.2.5 Paired design Another frequently used experimental design is a paired design, where measurements from multiple conditions (such as healthy biopsy and disease biopsy) are taken from a same subject. The statistical model for this experimental design is the same as in the time course experiment, however the values in the columns of the input data may have a different appearence. In this example there are 3 subjects (in general the number of patients can vary). There are three conditions per subject (in general the number of conditions per subject can exceed two). Overall, in this example there are \\(2 \\times 3 = 6\\) mass spectrometry runs. BioReplicate should indicate each individual ID. 2.1.6.1.3 Preprocessing with SkylinetoMSstatsFormat The input data for MSstats is required to contain variables of ProteinName, PeptideSequence, PrecursorCharge, FragmentIon, ProductCharge, IsotopeLabelType, Condition, BioReplicate, Run, Intensity. These variable names should be fixed. MSstats input from Skyline adapts the column scheme of the dataset so that it fits MSstats input format. However there are several extra column names and also some of them need to be changed. SkylinetoMSstatsFormat function helps pre-processing for making right format of MSstats input from Skyline output. For example, it renames some column name, and replace truncated peak intensities with NA. Another important step is to handle isotopic peaks before using dataProcess. The output from Skyline for DDA experiment has several measurements of peak area from the monoisotopic, M+1 and M+2 peaks. To get a robust measure of peptide intensity, we can sum over isotopic peaks per peptide or use the highest peak. Here we take a summation per peptide ion. Here is the summary of pre-processing steps in SkylinetoMSstatsFormat function (in orange box below). For further details, visit the help file using the following code. ?SkylinetoMSstatsFormat # reformating and pre-processing for Skyline output. input.skyline &lt;- SkylinetoMSstatsFormat(raw.skyline, annotation=annot.skyline, removeProtein_with1Feature = TRUE) ## ** Proteins, which names include DECOY, are removed. ## ** Peptides, that are used in more than one proteins, are removed. ## Warning in SkylinetoMSstatsFormat(raw.skyline, annotation = ## annot.skyline, : NAs introduced by coercion ## ** Truncated peaks are replaced with NA. ## ** For DDA datasets, three isotopic peaks per feature and run are summed. ## ** 4 features have all NAs or zero intensity values and are removed. ## ** 13 features have 1 or 2 intensities across runs and are removed. ## ** All proteins have at least two features. head(input.skyline) ## ProteinName PeptideSequence PrecursorCharge ## 1 sp|D6VTK4|STE2_YEAST EGEVEPVDM[+16]YTPDTAADEEARK 3 ## 2 sp|D6VTK4|STE2_YEAST EGEVEPVDM[+16]YTPDTAADEEARK 3 ## 3 sp|D6VTK4|STE2_YEAST EGEVEPVDM[+16]YTPDTAADEEARK 3 ## 4 sp|D6VTK4|STE2_YEAST EGEVEPVDM[+16]YTPDTAADEEARK 3 ## 5 sp|D6VTK4|STE2_YEAST EGEVEPVDM[+16]YTPDTAADEEARK 3 ## 6 sp|D6VTK4|STE2_YEAST EGEVEPVDM[+16]YTPDTAADEEARK 3 ## FragmentIon ProductCharge IsotopeLabelType Condition BioReplicate ## 1 sum NA L Condition1 1 ## 2 sum NA L Condition2 2 ## 3 sum NA L Condition4 4 ## 4 sum NA L Condition2 2 ## 5 sum NA L Condition4 4 ## 6 sum NA L Condition3 3 ## Run Intensity StandardType ## 1 JD_06232014_sample1_C.raw 7863713 NA ## 2 JD_06232014_sample2_A.raw 977615 NA ## 3 JD_06232014_sample4_B.raw 4102785 NA ## 4 JD_06232014_sample2_C.raw 6547299 NA ## 5 JD_06232014_sample4_C.raw 3972464 NA ## 6 JD_06232014_sample3_B.raw 8896052 NA 2.1.6.1.4 Preliminary check length(unique(input.skyline$ProteinName)) ## [1] 3027 sum(is.na(input.skyline$Intensity)) ## [1] 219 sum(!is.na(input.skyline$Intensity) &amp; input.skyline$Intensity==0) ## [1] 2414 2.1.6.2 MaxQuant output 2.1.6.2.1 Read data Three files should be prepared before MSstats. Two files, ‘proteinGroups.txt’ and ‘evidence.txt’ are outputs from MaxQuant. # First, get protein ID information proteinGroups &lt;- read.table(&quot;data/data_MaxQuant/proteinGroups.txt&quot;, sep = &quot;\\t&quot;, header = TRUE) # Read in MaxQuant file: evidence.txt evi &lt;- read.table(&quot;data/data_MaxQuant/evidence.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) colnames(evi) ## [1] &quot;Sequence&quot; ## [2] &quot;Length&quot; ## [3] &quot;Modifications&quot; ## [4] &quot;Modified.sequence&quot; ## [5] &quot;Oxidation..M..Probabilities&quot; ## [6] &quot;Oxidation..M..Score.Diffs&quot; ## [7] &quot;Acetyl..Protein.N.term.&quot; ## [8] &quot;Oxidation..M.&quot; ## [9] &quot;Missed.cleavages&quot; ## [10] &quot;Proteins&quot; ## [11] &quot;Leading.proteins&quot; ## [12] &quot;Leading.razor.protein&quot; ## [13] &quot;Gene.names&quot; ## [14] &quot;Protein.names&quot; ## [15] &quot;Type&quot; ## [16] &quot;Raw.file&quot; ## [17] &quot;MS.MS.m.z&quot; ## [18] &quot;Charge&quot; ## [19] &quot;m.z&quot; ## [20] &quot;Mass&quot; ## [21] &quot;Resolution&quot; ## [22] &quot;Uncalibrated...Calibrated.m.z..ppm.&quot; ## [23] &quot;Uncalibrated...Calibrated.m.z..Da.&quot; ## [24] &quot;Mass.Error..ppm.&quot; ## [25] &quot;Mass.Error..Da.&quot; ## [26] &quot;Uncalibrated.Mass.Error..ppm.&quot; ## [27] &quot;Uncalibrated.Mass.Error..Da.&quot; ## [28] &quot;Max.intensity.m.z.0&quot; ## [29] &quot;Retention.time&quot; ## [30] &quot;Retention.length&quot; ## [31] &quot;Calibrated.retention.time&quot; ## [32] &quot;Calibrated.retention.time.start&quot; ## [33] &quot;Calibrated.retention.time.finish&quot; ## [34] &quot;Retention.time.calibration&quot; ## [35] &quot;Match.time.difference&quot; ## [36] &quot;Match.m.z.difference&quot; ## [37] &quot;Match.q.value&quot; ## [38] &quot;Match.score&quot; ## [39] &quot;Number.of.data.points&quot; ## [40] &quot;Number.of.scans&quot; ## [41] &quot;Number.of.isotopic.peaks&quot; ## [42] &quot;PIF&quot; ## [43] &quot;Fraction.of.total.spectrum&quot; ## [44] &quot;Base.peak.fraction&quot; ## [45] &quot;PEP&quot; ## [46] &quot;MS.MS.Count&quot; ## [47] &quot;MS.MS.Scan.Number&quot; ## [48] &quot;Score&quot; ## [49] &quot;Delta.score&quot; ## [50] &quot;Combinatorics&quot; ## [51] &quot;Intensity&quot; ## [52] &quot;Reverse&quot; ## [53] &quot;Potential.contaminant&quot; ## [54] &quot;id&quot; ## [55] &quot;Protein.group.IDs&quot; ## [56] &quot;Peptide.ID&quot; ## [57] &quot;Mod..peptide.ID&quot; ## [58] &quot;MS.MS.IDs&quot; ## [59] &quot;Best.MS.MS&quot; ## [60] &quot;AIF.MS.MS.IDs&quot; ## [61] &quot;Oxidation..M..site.IDs&quot; unique(evi$Raw.file) ## [1] JD_06232014_sample1-A JD_06232014_sample2_A JD_06232014_sample4_B ## [4] JD_06232014_sample1_B JD_06232014_sample1_C JD_06232014_sample2_B ## [7] JD_06232014_sample2_C JD_06232014_sample3_A JD_06232014_sample3_B ## [10] JD_06232014_sample3_C JD_06232014_sample4-A JD_06232014_sample4_C ## 12 Levels: JD_06232014_sample1_B ... JD_06232014_sample4-A One file is for annotation information, required to fill in Condition and BioReplicate for corresponding Run information. Users have to prepare as csv or txt file like ‘ABRF2015_MaxQuant_annotation.csv’, which includes Run, Condition, and BioReplicate information, and load it in R. 2.1.6.2.2 Set annotation file Annotation information is required to fill in Condition and BioReplicate for corresponding Raw.file information. Users have to prepare as csv or txt file like ‘ABRF2015_MaxQuant_annotation.csv’, which includes Raw.file, Condition, and BioReplicate information, and load it in R. Raw.file column in the annotation file should be the same as unique Raw.file in evidence.txt file. # Read in annotation including condition and biological replicates: annotation.csv annot.maxquant &lt;- read.csv(&quot;data/data_MaxQuant/ABRF2015_MaxQuant_annotation.csv&quot;, header = TRUE) annot.maxquant ## Raw.file Condition BioReplicate IsotopeLabelType ## 1 JD_06232014_sample1-A Condition1 1 L ## 2 JD_06232014_sample2_A Condition2 2 L ## 3 JD_06232014_sample4_B Condition4 4 L ## 4 JD_06232014_sample1_B Condition1 1 L ## 5 JD_06232014_sample1_C Condition1 1 L ## 6 JD_06232014_sample2_B Condition2 2 L ## 7 JD_06232014_sample2_C Condition2 2 L ## 8 JD_06232014_sample3_A Condition3 3 L ## 9 JD_06232014_sample3_B Condition3 3 L ## 10 JD_06232014_sample3_C Condition3 3 L ## 11 JD_06232014_sample4-A Condition4 4 L ## 12 JD_06232014_sample4_C Condition4 4 L 2.1.6.2.3 Preprocessing with MaxQtoMSstatsFormat MaxQtoMSstatsFormat function helps pre-processing for making right format of MSstats input from MaxQuant output. Basically, this function gets peptide ion intensity from ‘evidence.txt’ file. In addition, there are several steps to filter out or to modify the data in order to get required information. Here is the summary of pre-processing steps in MaxQtoMSstatsFormat function (in orange box below). ?MaxQtoMSstatsFormat # reformating and pre-processing for MaxQuant output. # no protein with 1 peptide input.maxquant &lt;- MaxQtoMSstatsFormat(evidence=evi, annotation=annot.maxquant, proteinGroups=proteinGroups, removeProtein_with1Peptide=TRUE) ## ** + Contaminant, + Reverse, + Only.identified.by.site, proteins are removed. ## ** Peptide and charge, that have 1 or 2 measurements across runs, are removed. ## ** 282 proteins, which have only peptide and charge in a protein, are removed among 3157 proteins. head(input.maxquant) ## ProteinName PeptideSequence PrecursorCharge FragmentIon ## 1 D6VTK4 EGEVEPVDMYTPDTAADEEARK 3 NA ## 2 D6VTK4 FYPGTLSSFQTDSINNDAK 2 NA ## 3 D6VTK4 IGPFADASYK 2 NA ## 4 D6VTK4 NQFYQLPTPTSSK 2 NA ## 5 D6VTK4 TFVSETADDIEK 2 NA ## 6 D6VTK4 TNTITSDFTTSTDR 2 NA ## ProductCharge IsotopeLabelType Condition BioReplicate ## 1 NA L Condition1 1 ## 2 NA L Condition1 1 ## 3 NA L Condition1 1 ## 4 NA L Condition1 1 ## 5 NA L Condition1 1 ## 6 NA L Condition1 1 ## Run Intensity ## 1 JD_06232014_sample1_B 87141000 ## 2 JD_06232014_sample1_B 46167000 ## 3 JD_06232014_sample1_B 45425000 ## 4 JD_06232014_sample1_B 47094000 ## 5 JD_06232014_sample1_B NA ## 6 JD_06232014_sample1_B 62786000 2.1.6.2.4 Preliminary check length(unique(input.maxquant$ProteinName)) ## [1] 2875 sum(is.na(input.maxquant$Intensity)) ## [1] 40056 sum(!is.na(input.maxquant$Intensity) &amp; input.maxquant$Intensity==0) ## [1] 0 Challenge Let’s check unique information for Run,BioReplicate and Condition in input.maxquant. unique(input.maxquant[, c(&#39;Run&#39;, &#39;BioReplicate&#39;, &#39;Condition&#39;)]) ## Run BioReplicate Condition ## 1 JD_06232014_sample1_B 1 Condition1 ## 30600 JD_06232014_sample1_C 1 Condition1 ## 61199 JD_06232014_sample1-A 1 Condition1 ## 91798 JD_06232014_sample2_A 2 Condition2 ## 122397 JD_06232014_sample2_B 2 Condition2 ## 152996 JD_06232014_sample2_C 2 Condition2 ## 183595 JD_06232014_sample3_A 3 Condition3 ## 214194 JD_06232014_sample3_B 3 Condition3 ## 244793 JD_06232014_sample3_C 3 Condition3 ## 275392 JD_06232014_sample4_B 4 Condition4 ## 305991 JD_06232014_sample4_C 4 Condition4 ## 336590 JD_06232014_sample4-A 4 Condition4 2.1.6.3 OpenMS output 2.1.6.3.1 Read data # First, read output of OpenMS raw.openMS &lt;- read.csv(&quot;data/data_OpenMS/ABRF2015_OpenMS_raw.csv&quot;, stringsAsFactors=F) # the data file head(raw.openMS) ## ProteinName PeptideSequence PrecursorCharge FragmentIon ## 1 sp|P09938|RIR2_YEAST AAADALSDLEIK 2 NA ## 2 sp|P09938|RIR2_YEAST AAADALSDLEIK 2 NA ## 3 sp|P09938|RIR2_YEAST AAADALSDLEIK 2 NA ## 4 sp|P09938|RIR2_YEAST AAADALSDLEIK 2 NA ## 5 sp|P09938|RIR2_YEAST AAADALSDLEIK 2 NA ## 6 sp|P09938|RIR2_YEAST AAADALSDLEIK 2 NA ## ProductCharge IsotopeLabelType Condition BioReplicate Run Intensity ## 1 0 L 1 1 1 391797000 ## 2 0 L 4 4 10 103656000 ## 3 0 L 4 4 11 361107000 ## 4 0 L 1 1 2 456756000 ## 5 0 L 1 1 3 389268000 ## 6 0 L 2 2 4 433488000 2.1.6.3.2 Set annotation file The output from OpenMS already includes Run, BioReplicate, Condition information. Let’s check it. unique(raw.openMS[, c(&#39;Run&#39;, &#39;BioReplicate&#39;, &#39;Condition&#39;)]) ## Run BioReplicate Condition ## 1 1 1 1 ## 2 10 4 4 ## 3 11 4 4 ## 4 2 1 1 ## 5 3 1 1 ## 6 4 2 2 ## 7 5 2 2 ## 8 6 2 2 ## 9 7 3 3 ## 10 8 3 3 ## 11 9 3 3 ## 14 12 4 4 2.1.6.3.3 Preprocessing with OpenMStoMSstatsFormat There are several steps to filter out or to modify the data in order to get required information. Here is the summary of pre-processing steps in OpenMStoMSstatsFormat function. ?OpenMStoMSstatsFormat # reformating and pre-processing for OpenMS output. input.openms &lt;- OpenMStoMSstatsFormat(raw.openMS, removeProtein_with1Feature=TRUE) ## ** 0 features have all NAs or zero intensity values and are removed. ## ** All peptides are unique peptides in proteins. ## ** 909 features have 1 or 2 intensities across runs and are removed. ## ** 698 proteins, which have only one feature in a protein, are removed among 2538 proteins. ## ** No multiple measurements in a feature and a run. ## Warning in OpenMStoMSstatsFormat(raw.openMS, removeProtein_with1Feature = ## TRUE): NAs introduced by coercion ## now &#39;input.openms&#39; is ready for MSstats head(input.openms) ## ProteinName PeptideSequence PrecursorCharge FragmentIon ## 1 sp|D6VTK4|STE2_YEAST EGEVEPVDMYTPDTAADEEARK 3 NA ## 2 sp|D6VTK4|STE2_YEAST FYPGTLSSFQTDSINNDAK 2 NA ## 3 sp|D6VTK4|STE2_YEAST IGPFADASYK 2 NA ## 4 sp|D6VTK4|STE2_YEAST NQFYQLPTPTSSK 2 NA ## 5 sp|D6VTK4|STE2_YEAST TFVSETADDIEK 2 NA ## 6 sp|D6VTK4|STE2_YEAST TNTITSDFTTSTDR 2 NA ## ProductCharge IsotopeLabelType Condition BioReplicate Run Intensity ## 1 0 L 1 1 1 64757900 ## 2 0 L 1 1 1 38852700 ## 3 0 L 1 1 1 73225800 ## 4 0 L 1 1 1 63139900 ## 5 0 L 1 1 1 NA ## 6 0 L 1 1 1 58905300 2.1.6.3.4 Preliminary check for preprocessed data length(unique(input.openms$ProteinName)) ## [1] 1840 sum(is.na(input.openms$Intensity)) ## [1] 21962 sum(!is.na(input.openms$Intensity) &amp; input.openms$Intensity==0) ## [1] 0 table(input.openms$Run) ## ## 1 2 3 4 5 6 7 8 9 10 11 12 ## 15560 15560 15560 15560 15560 15560 15560 15560 15560 15560 15560 15560 Challenge Let’s check unique information for Run,BioReplicate and Condition. unique(input.openms[, c(&#39;Run&#39;, &#39;BioReplicate&#39;, &#39;Condition&#39;)]) ## Run BioReplicate Condition ## 1 1 1 1 ## 15561 10 4 4 ## 31121 11 4 4 ## 46681 12 4 4 ## 62241 2 1 1 ## 77801 3 1 1 ## 93361 4 2 2 ## 108921 5 2 2 ## 124481 6 2 2 ## 140041 7 3 3 ## 155601 8 3 3 ## 171161 9 3 3 2.1.6.4 Progenesis output 2.1.6.4.1 Read data # First, read output of Progenesis raw.progenesis &lt;- read.csv(&quot;data/data_Progenesis/ABRF2015_Progenesis_raw.csv&quot;, stringsAsFactors=F) # the data file head(raw.progenesis) ## X X.1 X.2 X.3 X.4 ## 1 ## 2 # Retention time (min) Charge m/z Measured mass ## 3 16 52.5563333333333 2 501.781277638303 1001.54800234285 ## 4 32 38.15255 2 474.251481407549 946.488409881339 ## 5 11167 36.2224333333333 2 474.25154745893 946.488541984099 ## 6 41 45.5598 2 371.731536419815 741.448519905869 ## X.5 X.6 X.7 X.8 X.9 ## 1 ## 2 Mass error (u) Mass error (ppm) Score Sequence Modifications ## 3 -0.00255665715405939 -2.55269904358308 1 TANDVLTIR ## 4 -0.00219111866147159 -2.31499251990099 1 VTDGVMVAR ## 5 -0.0020590159006133 -2.17542139186367 1 VTDGVMVAR ## 6 -0.00120309413080122 -1.62262402086192 0.9996 AGLNIVR ## X.10 ## 1 ## 2 Accession ## 3 sp|P00549|KPYK1_YEAST ## 4 sp|P00549|KPYK1_YEAST ## 5 sp|P00549|KPYK1_YEAST ## 6 sp|P00549|KPYK1_YEAST ## X.11 ## 1 ## 2 Description ## 3 Pyruvate kinase 1 OS=Saccharomyces cerevisiae (strain ATCC 204508 \\\\ S288c) GN=CDC19 PE=1 SV=2 ## 4 Pyruvate kinase 1 OS=Saccharomyces cerevisiae (strain ATCC 204508 \\\\ S288c) GN=CDC19 PE=1 SV=2 ## 5 Pyruvate kinase 1 OS=Saccharomyces cerevisiae (strain ATCC 204508 \\\\ S288c) GN=CDC19 PE=1 SV=2 ## 6 Pyruvate kinase 1 OS=Saccharomyces cerevisiae (strain ATCC 204508 \\\\ S288c) GN=CDC19 PE=1 SV=2 ## X.12 X.13 X.14 ## 1 ## 2 Use in quantitation Max fold change Highest mean condition ## 3 False 1.23101575731737 A ## 4 False 1.35108253622201 B ## 5 False 1.25419527606242 B ## 6 False 1.04868912680216 A ## X.15 X.16 X.17 ## 1 ## 2 Lowest mean condition Anova Maximum CV ## 3 C 0.0522715538027003 12.0175133289667 ## 4 A 0.0393818452091522 26.8776079679151 ## 5 A 0.253277920596793 27.2310093101224 ## 6 B 0.993981434364646 27.0631636013386 ## Normalized.abundance X.18 X.19 ## 1 A ## 2 JD_06232014_sample1-A JD_06232014_sample2_A JD_06232014_sample3_A ## 3 234646642.659118 246323351.490501 306102714.66799 ## 4 179120293.733639 104309665.701784 136741892.392964 ## 5 2233197.90782367 1134566.5998162 1574437.81004362 ## 6 123797188.716029 122761256.64621 116107425.243685 ## X.20 X.21 X.22 ## 1 B ## 2 JD_06232014_sample4-A JD_06232014_sample1_B JD_06232014_sample2_B ## 3 257629531.217182 235779468.539422 236753257.546934 ## 4 105011188.469111 182469696.644175 183285243.781685 ## 5 1701362.72342001 2336796.51015815 1788630.29256942 ## 6 63610598.879437 108255803.660911 108785457.069653 ## X.23 X.24 X.25 ## 1 C ## 2 JD_06232014_sample3_B JD_06232014_sample4_B JD_06232014_sample1_C ## 3 186699807.218591 242959514.796972 223435557.783206 ## 4 162853464.030243 180957229.609825 186073547.948691 ## 5 1932732.32106691 2274168.76697097 2182403.4051037 ## 6 92469286.5619254 96974519.2450418 115737794.475905 ## X.26 X.27 X.28 ## 1 ## 2 JD_06232014_sample2_C JD_06232014_sample3_C JD_06232014_sample4_C ## 3 220456628.684641 197285091.954229 207473304.500931 ## 4 163946644.909844 150247529.397207 176820166.306319 ## 5 2040841.8048229 1497501.50492545 2156318.09540588 ## 6 100428622.768589 109442962.863466 83998024.0208531 ## Raw.abundance X.29 X.30 ## 1 A ## 2 JD_06232014_sample1-A JD_06232014_sample2_A JD_06232014_sample3_A ## 3 244531299.931508 221199440.186087 277078923.760572 ## 4 186665863.932395 93670533.1411598 123776414.130536 ## 5 2327272.96336292 1018845.73758267 1425154.0840074 ## 6 129012233.635811 110240142.001841 105098448.610706 ## X.31 X.32 X.33 ## 1 B ## 2 JD_06232014_sample4-A JD_06232014_sample1_B JD_06232014_sample2_B ## 3 213112377.670857 265826760.55748 265610928.042007 ## 4 86865756.2312952 205723291.596601 205625739.64841 ## 5 1407375.36397932 2634593.46237989 2006645.04833363 ## 6 52618990.9526949 122051719.672593 122045231.85501 ## X.34 X.35 X.36 ## 1 C ## 2 JD_06232014_sample3_B JD_06232014_sample4_B JD_06232014_sample1_C ## 3 219812880.452275 242959514.796972 210648874.118526 ## 4 191737150.420336 180957229.609825 175425002.929311 ## 5 2275521.67817463 2274168.76697097 2057509.66730008 ## 6 108869636.960823 96974519.2450418 109114396.746851 ## X.37 X.38 X.39 ## 1 ## 2 JD_06232014_sample2_C JD_06232014_sample3_C JD_06232014_sample4_C ## 3 207260386.701525 217212520.118758 194785326.277837 ## 4 154133015.755399 165423774.187439 166006773.109084 ## 5 1918679.71576989 1648761.5589421 2024448.99975338 ## 6 94417098.3431607 120497608.498225 78861145.7987456 ## Spectral.counts X.40 X.41 ## 1 A ## 2 JD_06232014_sample1-A JD_06232014_sample2_A JD_06232014_sample3_A ## 3 2 1 1 ## 4 1 1 1 ## 5 1 0 1 ## 6 2 2 2 ## X.42 X.43 X.44 ## 1 B ## 2 JD_06232014_sample4-A JD_06232014_sample1_B JD_06232014_sample2_B ## 3 3 2 3 ## 4 1 1 1 ## 5 1 0 0 ## 6 2 2 2 ## X.45 X.46 X.47 ## 1 C ## 2 JD_06232014_sample3_B JD_06232014_sample4_B JD_06232014_sample1_C ## 3 2 2 2 ## 4 1 1 1 ## 5 0 1 1 ## 6 2 2 2 ## X.48 X.49 X.50 ## 1 ## 2 JD_06232014_sample2_C JD_06232014_sample3_C JD_06232014_sample4_C ## 3 3 1 2 ## 4 1 1 1 ## 5 0 1 0 ## 6 2 2 2 One file is for annotation information, required to fill in Condition and BioReplicate for corresponding Run information. Users have to prepare as csv or txt file like ‘ABRF2015_Progenesis_annotation.csv’, which includes Run, Condition, and BioReplicate information, and load it in R. 2.1.6.4.2 Set annotation file Annotation information is required to fill in Condition and BioReplicate for corresponding Run information. Users have to prepare as csv or txt file like ‘ABRF2015_Progenesis_annotation.csv’, which includes Run, Condition, and BioReplicate information, and load it in R. ## Read in annotation including condition and biological replicates: ABRF2015_Progenesis_annotation.csv annot.progenesis &lt;- read.csv(&quot;data/data_Progenesis/ABRF2015_Progenesis_annotation.csv&quot;, header = TRUE) annot.progenesis ## Run Condition BioReplicate ## 1 JD_06232014_sample1-A Condition1 1 ## 2 JD_06232014_sample2_A Condition2 2 ## 3 JD_06232014_sample4_B Condition4 4 ## 4 JD_06232014_sample1_B Condition1 1 ## 5 JD_06232014_sample1_C Condition1 1 ## 6 JD_06232014_sample2_B Condition2 2 ## 7 JD_06232014_sample2_C Condition2 2 ## 8 JD_06232014_sample3_A Condition3 3 ## 9 JD_06232014_sample3_B Condition3 3 ## 10 JD_06232014_sample3_C Condition3 3 ## 11 JD_06232014_sample4-A Condition4 4 ## 12 JD_06232014_sample4_C Condition4 4 !! Run information should be the same as annotated in output of Progenesis. 2.1.6.4.3 Preprocessing with ProgenesistoMSstatsFormat The output from Progenesis includes peptide ion-level quantification for each MS runs. ProgenesistoMSstatsFormat function helps pre-processing for making right format of MSstats input from Progenesis output. Basically, this function reformats wide format to long format. It provide Raw.abundance, Normalized.abundance and Spectral count columns. This converter uses Raw.abundance columns for Intensity values. In addition, there are several steps to filter out or to modify the data in order to get required information. Here is the summary of pre-processing steps in ProgenesistoMSstatsFormat function (in orange box below). ?ProgenesistoMSstatsFormat # reformating and pre-processing for Progenesis output. input.progenesis &lt;- ProgenesistoMSstatsFormat(raw.progenesis, annotation=annot.progenesis, removeProtein_with1Peptide=TRUE) ## ** Peptides, that are used in more than one proteins, are removed. ## ** Multiple measurements in a feature and a run are summarized by summaryforMultipleRows. ## ** 898 proteins, which have only one feature in a protein, are removed among 3913 proteins. ## now &#39;input.progenesis&#39; is ready for MSstats head(input.progenesis) ## ProteinName PeptideModifiedSequence PrecursorCharge ## 1 sp|A5Z2X5|YP010_YEAST LTGNPELSSLDEVLAK 2 ## 2 sp|A5Z2X5|YP010_YEAST RPAQLLL[N-term] nTerm+42.0106 2 ## 3 sp|D6VTK4|STE2_YEAST EGEVEPVDMYTPDTAADEEARK 3 ## 4 sp|D6VTK4|STE2_YEAST FYPGTLSSFQTDSINNDAK 2 ## 5 sp|D6VTK4|STE2_YEAST IGPFADASYK 2 ## 6 sp|O13297|CET1_YEAST IAGNAVGSVVK 2 ## FragmentIon ProductCharge IsotopeLabelType Condition BioReplicate ## 1 NA NA L Condition1 1 ## 2 NA NA L Condition1 1 ## 3 NA NA L Condition1 1 ## 4 NA NA L Condition1 1 ## 5 NA NA L Condition1 1 ## 6 NA NA L Condition1 1 ## Run Intensity ## 1 JD_06232014_sample1_B 2550357.3 ## 2 JD_06232014_sample1_B 865491.8 ## 3 JD_06232014_sample1_B 3767734.3 ## 4 JD_06232014_sample1_B 2591735.2 ## 5 JD_06232014_sample1_B 2301483.1 ## 6 JD_06232014_sample1_B 415181.8 2.1.6.4.4 Preliminary check for preprocessed data length(unique(input.progenesis$ProteinName)) ## [1] 3015 sum(is.na(input.progenesis$Intensity)) ## [1] 0 sum(!is.na(input.progenesis$Intensity) &amp; input.progenesis$Intensity==0) ## [1] 418 table(input.progenesis$Run) ## ## JD_06232014_sample1-A JD_06232014_sample2_A JD_06232014_sample3_A ## 9646 9646 9646 ## JD_06232014_sample4-A JD_06232014_sample1_B JD_06232014_sample2_B ## 9646 9646 9646 ## JD_06232014_sample3_B JD_06232014_sample4_B JD_06232014_sample1_C ## 9646 9646 9646 ## JD_06232014_sample2_C JD_06232014_sample3_C JD_06232014_sample4_C ## 9646 9646 9646 Challenge Let’s check unique information for Run,BioReplicate and Condition. unique(input.progenesis[, c(&#39;Run&#39;, &#39;BioReplicate&#39;, &#39;Condition&#39;)]) ## Run BioReplicate Condition ## 1 JD_06232014_sample1_B 1 Condition1 ## 10547 JD_06232014_sample1_C 1 Condition1 ## 21093 JD_06232014_sample1-A 1 Condition1 ## 31639 JD_06232014_sample2_A 2 Condition2 ## 42185 JD_06232014_sample2_B 2 Condition2 ## 52731 JD_06232014_sample2_C 2 Condition2 ## 63277 JD_06232014_sample3_A 3 Condition3 ## 73823 JD_06232014_sample3_B 3 Condition3 ## 84369 JD_06232014_sample3_C 3 Condition3 ## 94915 JD_06232014_sample4_B 4 Condition4 ## 105461 JD_06232014_sample4_C 4 Condition4 ## 116007 JD_06232014_sample4-A 4 Condition4 2.1.7 Save your work We can save the data that we made so far. save(input.skyline, file=&#39;data/data_Skyline/input.skyline.rda&#39;) save(input.maxquant, file=&#39;data/data_MaxQuant/input.maxquant.rda&#39;) save(input.openms, file=&#39;data/data_OpenMS/input.openms.rda&#39;) save(input.progenesis, file=&#39;data/data_Progenesis/input.progenesis.rda&#39;) 2.2 Data processing - Normalization and run summarization 2.2.1 dataProcess with Skyline data Let’s start processing steps. It includes log transformation of intensities, normalization and run-level summarization. 2.2.1.1 Load the pre-processed data of Skyline output load(file=&#39;data/data_Skyline/input.skyline.rda&#39;) 2.2.1.2 Normalizing and summarizing data with dataProcess ! Always pay attention to the default options To get started with this function, visit the help section of dataProcess first: ?dataProcess 2.2.1.2.1 Default normalization and summarization options dataProcess perform (1) normalization first. The default option for normalization is equalizeMedians. `equalizeMedians’ fits for label-based SRM experiments, which we can use reference signals. There are three more options for normalization. Depending on the suitable assumption for your experiment, you can choose one of them. Then, (2) run level summarization will be performed including missing value imputation by accerelated failure model and robust parameter estimation by TMP (Tukey’s median polish). Below show the default for all options in dataProcess except censoredInt. censoredInt='0' should be used for Skyline output. quant.skyline &lt;- dataProcess(raw = input.skyline, logTrans=2, normalization = &#39;equalizeMedians&#39;, summaryMethod = &#39;TMP&#39;, MBimpute=TRUE, censoredInt=&#39;0&#39;, cutoffCensored=&#39;minFeature&#39;, maxQuantileforCensored = 0.999) Let’s check output from dataProcess. # show the name of outputs names(quant.skyline) ## [1] &quot;ProcessedData&quot; &quot;RunlevelData&quot; &quot;SummaryMethod&quot; ## [4] &quot;ModelQC&quot; &quot;PredictBySurvival&quot; # show reformated and normalized data. # &#39;ABUNDANCE&#39; column has normalized log2 transformed intensities. head(quant.skyline$ProcessedData) ## PROTEIN PEPTIDE TRANSITION ## 10 sp|D6VTK4|STE2_YEAST EGEVEPVDM[+16]YTPDTAADEEARK_3 sum_NA ## 16 sp|D6VTK4|STE2_YEAST EGEVEPVDMYTPDTAADEEARK_3 sum_NA ## 36 sp|D6VTK4|STE2_YEAST FYPGTLSSFQTDSINNDAK_2 sum_NA ## 37 sp|D6VTK4|STE2_YEAST IGPFADASYK_2 sum_NA ## 59 sp|D6VTK4|STE2_YEAST KETTSDK_2 sum_NA ## 65 sp|D6VTK4|STE2_YEAST NQFYQLPTPTSSK_2 sum_NA ## FEATURE LABEL GROUP_ORIGINAL ## 10 EGEVEPVDM[+16]YTPDTAADEEARK_3_sum_NA L Condition1 ## 16 EGEVEPVDMYTPDTAADEEARK_3_sum_NA L Condition1 ## 36 FYPGTLSSFQTDSINNDAK_2_sum_NA L Condition1 ## 37 IGPFADASYK_2_sum_NA L Condition1 ## 59 KETTSDK_2_sum_NA L Condition1 ## 65 NQFYQLPTPTSSK_2_sum_NA L Condition1 ## SUBJECT_ORIGINAL RUN GROUP SUBJECT INTENSITY SUBJECT_NESTED ABUNDANCE ## 10 1 1 1 1 5222795 1.1 22.07301 ## 16 1 1 1 1 182195648 1.1 27.19754 ## 36 1 1 1 1 86229170 1.1 26.11829 ## 37 1 1 1 1 157996653 1.1 26.99194 ## 59 1 1 1 1 177684007 1.1 27.16136 ## 65 1 1 1 1 140368798 1.1 26.82127 ## FRACTION originalRUN censored ## 10 1 JD_06232014_sample1_B.raw FALSE ## 16 1 JD_06232014_sample1_B.raw FALSE ## 36 1 JD_06232014_sample1_B.raw FALSE ## 37 1 JD_06232014_sample1_B.raw FALSE ## 59 1 JD_06232014_sample1_B.raw FALSE ## 65 1 JD_06232014_sample1_B.raw FALSE # This table includes run-level summarized log2 intensities. (column : LogIntensities) # Now one summarized log2 intensities per Protein and Run. # NumMeasuredFeature : show how many features are used for run-level summarization. # If there is no missing value, it should be the number of features in certain protein. # MissingPercentage : the number of missing features / the number of features in certain protein. head(quant.skyline$RunlevelData) ## RUN Protein LogIntensities NumMeasuredFeature ## 1 1 sp|D6VTK4|STE2_YEAST 26.81180 8 ## 2 2 sp|D6VTK4|STE2_YEAST 26.60824 8 ## 3 3 sp|D6VTK4|STE2_YEAST 26.58246 8 ## 4 4 sp|D6VTK4|STE2_YEAST 26.83600 8 ## 5 5 sp|D6VTK4|STE2_YEAST 26.79392 8 ## 6 6 sp|D6VTK4|STE2_YEAST 26.60783 8 ## MissingPercentage more50missing NumImputedFeature ## 1 0 FALSE 0 ## 2 0 FALSE 0 ## 3 0 FALSE 0 ## 4 0 FALSE 0 ## 5 0 FALSE 0 ## 6 0 FALSE 0 ## originalRUN GROUP GROUP_ORIGINAL SUBJECT_ORIGINAL ## 1 JD_06232014_sample1_B.raw 1 Condition1 1 ## 2 JD_06232014_sample1_C.raw 1 Condition1 1 ## 3 JD_06232014_sample1-A.raw 1 Condition1 1 ## 4 JD_06232014_sample2_A.raw 2 Condition2 2 ## 5 JD_06232014_sample2_B.raw 2 Condition2 2 ## 6 JD_06232014_sample2_C.raw 2 Condition2 2 ## SUBJECT_NESTED SUBJECT ## 1 1.1 1 ## 2 1.1 1 ## 3 1.1 1 ## 4 2.2 2 ## 5 2.2 2 ## 6 2.2 2 # show which summarization method is used. head(quant.skyline$SummaryMethod) ## [1] &quot;TMP&quot; 2.2.1.3 Visualization of processed data 2.2.1.3.1 Quality control plots Now let’s look at what the equalize medians procedure did to our data. QC plot is good to see the distribution of intensities per MS run and outliers. So, it is good visualization to check normalization. However, not good to see individual intensities. # QC plot for normalized data with equalize median method dataProcessPlots(data = quant.skyline, type=&quot;QCplot&quot;, width=7, height=7, which.Protein = &#39;allonly&#39;, address=&#39;data/data_Skyline/ABRF_skyline_equalizeNorm_&#39;) Then, ABRF_skyline_equalizeNorm_QCPlot.pdf are generated in the currect directory. Now the median log2 intensities per run across MS runs (lines in the boxes) are the same. 2.2.1.3.2 Profile plots Profile plot is good visualization to check individual measurements. Each dot means one intensity. The dots are linked with line per feature. If line is disconnected, that means there is no value (missing value). Color means different peptides and charge stages. Different line type means different transition. # if you have many MS runs, adjust width of plot (makd wider) # Profile plot for the data with equalized median method dataProcessPlots(data = quant.skyline, type=&quot;Profileplot&quot;, width=7, height=7, address=&quot;data/data_Skyline/ABRF_skyline_equalizeNorm_&quot;) ABRF_skyline_equalizeNorm_ProfilePlot.pdf and ABRF_skyline_equalizeNorm_ProfilePlot_wSummarization.pdf are generated in the current directory. Then, Let’s go though profile plots to see overall quality of data. There are two pdfs for each protein, first is profile plot with normalized data and second plot is profile plot with normalilzed data and summarized data. This profile plot shows each peptide transition across runs, grouped per condition. Ech peptide has a different colour/type layout. This plot shows The panel on the right shows the same transitions in grey, with the values as summarized by the model overlayed in red. Instead of making all profile plots for all proteins, we can make plot for individual protein. Here is the example of spike-in protein, sp|P44015|VAC2_YEAST dataProcessPlots(data = quant.skyline, type=&quot;Profileplot&quot;, featureName=&quot;NA&quot;, width=7, height=7, which.Protein = &#39;sp|P44015|VAC2_YEAST&#39;, address=&quot;data/data_Skyline/ABRF_skyline_equalizeNorm_P44015_&quot;) 2.2.1.3.3 Condition plots Condition plots illustrate the systematic difference between conditions. The dots indicates the mean of all summarized intensities in each condition and default error bar is CI with 0.95 significant level. However, it is not related with model-based analysis. dataProcessPlots(data = quant.skyline, type=&quot;conditionplot&quot;, width=7, height=7, address=&quot;data/data_Skyline/ABRF_skyline_equalizeNorm_&quot;) We can draw the condition plot for a protein, sp|P44015|VAC2_YEAST . dataProcessPlots(data = quant.skyline, type=&quot;conditionplot&quot;, width=7, height=7, which.Protein = &#39;sp|P44015|VAC2_YEAST&#39;, address=&quot;data/data_Skyline/ABRF_skyline_equalizeNorm_P44015_&quot;) Challenge This is the study design. Let’s check visualization for other 5 spike-in proteins. 1. sp|P55752|ISCB_YEAST 2. sp|P44374|SFG2_YEAST 3. sp|P44983|UTR6_YEAST 4. sp|P44683|PGA4_YEAST 5. sp|P55249|ZRT4_YEAST Experimental design for spike-in proteins 2.2.1.4 Different normalization option Let’s see the different normalization effect with SRM dataset including two proteins head(SRMRawData) ## ProteinName PeptideSequence PrecursorCharge FragmentIon ProductCharge ## 243 IDHC ATDVIVPEEGELR 2 y7 NA ## 244 IDHC ATDVIVPEEGELR 2 y7 NA ## 245 IDHC ATDVIVPEEGELR 2 y8 NA ## 246 IDHC ATDVIVPEEGELR 2 y8 NA ## 247 IDHC ATDVIVPEEGELR 2 y9 NA ## 248 IDHC ATDVIVPEEGELR 2 y9 NA ## IsotopeLabelType Condition BioReplicate Run Intensity ## 243 H 1 ReplA 1 84361.08350 ## 244 L 1 ReplA 1 215.13526 ## 245 H 1 ReplA 1 29778.10188 ## 246 L 1 ReplA 1 98.02134 ## 247 H 1 ReplA 1 17921.29255 ## 248 L 1 ReplA 1 60.47029 unique(SRMRawData$ProteinName) ## [1] IDHC PMG2 ## 45 Levels: ACEA ACH1 ACON ADH1 ADH2 ADH4 ALDH6 ALF CISY1 CISY2 ... SUCB 2.2.1.4.1 No normalization No normalization is performed. If you had your own normalization before MSstats, you should use like below. srm.nonorm &lt;- dataProcess(SRMRawData, normalization=FALSE) dataProcessPlots(srm.nonorm, type=&#39;QCplot&#39;, address=&#39;srm_noNorm_&#39;) 2.2.1.4.2 Equalize medians normalization The default option for normalization is ‘equalizeMedians’, where all the intensities in a run are shifted by a constant, to equalize the median of intensities across runs for label-free experiment. This normalization method is appropriate when we can assume that the majority of proteins do not change across runs. Be cautious when using the equalizeMedians option for a label-free DDA dataset with only a small number of proteins. For label based experiment, equalizeMedians equalizes the median of reference intensities across runs and is generally proper even for a dataset with a small number of proteins. srm.equalmed &lt;- dataProcess(SRMRawData, normalization = &#39;equalizeMedians&#39;) dataProcessPlots(srm.equalmed, type=&#39;QCplot&#39;, address=&#39;srm_equalM_&#39;) 2.2.1.4.3 Quantile normalization The distribution of all the intensities in each run will become the same across runs for label-free experiment. For label-based experiment, the distribution of all the reference intensities will be become the same across runs and all the endogenous intensities are shifted by a constant corresponding to reference intensities. srm.quantile &lt;- dataProcess(SRMRawData, normalization=&#39;quantile&#39;) dataProcessPlots(srm.quantile, type=&#39;QCplot&#39;, address=&#39;srm_quantile_&#39;) 2.2.1.4.4 Global standards normalization : example 1 If you have a spiked in standard across all MS runs, you may set this to globalStandards and define the standard with nameStandards option. Global standard peptide or Protein names, which you can assume that they have the same abundance across MS runs, should be assigned in the vector for this option. First, let’s assume that PMG2 proteins is the spike-in protein and shoule be equal amount across MS runs. srm.global.pmg2 &lt;- dataProcess(SRMRawData, normalization =&#39;globalStandards&#39;, nameStandards = &#39;PMG2&#39;) dataProcessPlots(srm.global.pmg2, type=&#39;QCplot&#39;, address=&#39;srm_global_PMG2_&#39;) Second, let’s assume that IDHC proteins is the spike-in protein and shoule be equal amount across MS runs. 2.2.1.4.5 Global standards normalization : example 2 srm.global.idhc &lt;- dataProcess(SRMRawData, normalization =&#39;globalStandards&#39;, nameStandards = &#39;IDHC&#39;) dataProcessPlots(srm.global.idhc, type=&#39;QCplot&#39;, address=&#39;srm_global_IDHC_&#39;) 2.2.1.5 Different summarization option Here is the summary of combinations for imputation options with summaryMethod=‘TMP’. MBimpute=TRUE : AFT model-based imputation using cutoffCensored value in the AFT model. The default option for cutoffCensored is minFeature, taking the minimum value for the corresponding feature. With this option, those runs with substantial missing measurements will be biased by the cutoff value. In such case, you may remove the runs that have more than 50% missing values from the analysis with the option remove50missing=TRUE. In case that there are completely missing measurements in a run for a protein, any imputation will not be performed. 2.2.1.5.1 No imputation, TMP summarization only quant.skyline.TMPonly &lt;- dataProcess(raw = input.skyline, logTrans=2, summaryMethod = &#39;TMP&#39;, MBimpute=FALSE, ## censoredInt=&#39;0&#39;, cutoffCensored=&#39;minFeature&#39;, maxQuantileforCensored = 0.999) The column, censored, is not in the processed data any more. head(quant.skyline.TMPonly$ProcessedData) ## PROTEIN PEPTIDE TRANSITION ## 27092 sp|D6VTK4|STE2_YEAST EGEVEPVDM[+16]YTPDTAADEEARK_3 sum_NA ## 10700 sp|D6VTK4|STE2_YEAST EGEVEPVDMYTPDTAADEEARK_3 sum_NA ## 20407 sp|D6VTK4|STE2_YEAST FYPGTLSSFQTDSINNDAK_2 sum_NA ## 2213 sp|D6VTK4|STE2_YEAST IGPFADASYK_2 sum_NA ## 938 sp|D6VTK4|STE2_YEAST KETTSDK_2 sum_NA ## 26116 sp|D6VTK4|STE2_YEAST NQFYQLPTPTSSK_2 sum_NA ## FEATURE LABEL GROUP_ORIGINAL ## 27092 EGEVEPVDM[+16]YTPDTAADEEARK_3_sum_NA L Condition1 ## 10700 EGEVEPVDMYTPDTAADEEARK_3_sum_NA L Condition1 ## 20407 FYPGTLSSFQTDSINNDAK_2_sum_NA L Condition1 ## 2213 IGPFADASYK_2_sum_NA L Condition1 ## 938 KETTSDK_2_sum_NA L Condition1 ## 26116 NQFYQLPTPTSSK_2_sum_NA L Condition1 ## SUBJECT_ORIGINAL RUN GROUP SUBJECT SUBJECT_NESTED INTENSITY ## 27092 1 1 1 1 1.1 5222795 ## 10700 1 1 1 1 1.1 182195648 ## 20407 1 1 1 1 1.1 86229170 ## 2213 1 1 1 1 1.1 157996653 ## 938 1 1 1 1 1.1 177684007 ## 26116 1 1 1 1 1.1 140368798 ## ABUNDANCE METHOD originalRUN ## 27092 22.07353 1 JD_06232014_sample1_B.raw ## 10700 27.19805 1 JD_06232014_sample1_B.raw ## 20407 26.11881 1 JD_06232014_sample1_B.raw ## 2213 26.99246 1 JD_06232014_sample1_B.raw ## 938 27.16188 1 JD_06232014_sample1_B.raw ## 26116 26.82179 1 JD_06232014_sample1_B.raw 2.2.2 dataProcess with MaxQuant data load(file=&#39;data/data_MaxQuant/input.maxquant.rda&#39;) head(input.maxquant) ## ProteinName PeptideSequence PrecursorCharge FragmentIon ## 1 D6VTK4 EGEVEPVDMYTPDTAADEEARK 3 NA ## 2 D6VTK4 FYPGTLSSFQTDSINNDAK 2 NA ## 3 D6VTK4 IGPFADASYK 2 NA ## 4 D6VTK4 NQFYQLPTPTSSK 2 NA ## 5 D6VTK4 TFVSETADDIEK 2 NA ## 6 D6VTK4 TNTITSDFTTSTDR 2 NA ## ProductCharge IsotopeLabelType Condition BioReplicate ## 1 NA L Condition1 1 ## 2 NA L Condition1 1 ## 3 NA L Condition1 1 ## 4 NA L Condition1 1 ## 5 NA L Condition1 1 ## 6 NA L Condition1 1 ## Run Intensity ## 1 JD_06232014_sample1_B 87141000 ## 2 JD_06232014_sample1_B 46167000 ## 3 JD_06232014_sample1_B 45425000 ## 4 JD_06232014_sample1_B 47094000 ## 5 JD_06232014_sample1_B NA ## 6 JD_06232014_sample1_B 62786000 sum(is.na(input.maxquant$Intensity)) ## [1] 40056 sum(!is.na(input.maxquant$Intensity) &amp; input.maxquant$Intensity==0) ## [1] 0 Note! MaxQuant output has only NA. censoredInt=‘NA’ should be used for MaxQuant output. Challenges Try dataProcess with equalize median normalization for MaxQuant output. (input.maxquant.rda from section 1) quant.maxquant &lt;- dataProcess(raw = input.maxquant, logTrans=2, #normalization = &#39;quantile&#39;, summaryMethod = &#39;TMP&#39;, MBimpute=TRUE, censoredInt=&#39;NA&#39;, cutoffCensored=&#39;minFeature&#39;, maxQuantileforCensored = 0.999) Try dataProcess with quantile normalization for MaxQuant output. (input.maxquant.rda from section 1) quant.maxquant.quantile &lt;- dataProcess(raw = input.maxquant, logTrans=2, normalization = &#39;quantile&#39;, summaryMethod = &#39;TMP&#39;, MBimpute=TRUE, censoredInt=&#39;NA&#39;, cutoffCensored=&#39;minFeature&#39;, maxQuantileforCensored = 0.999) Draw QC plots for both cases above and compare. dataProcessPlots(data = quant.maxquant, type=&quot;QCplot&quot;, width=7, height=7, which.Protein = &#39;allonly&#39;, address=&#39;data/data_MaxQuant/ABRF_maxquant_equalMed_&#39;) dataProcessPlots(data = quant.maxquant.quantile, type=&quot;QCplot&quot;, width=7, height=7, which.Protein = &#39;allonly&#39;, address=&#39;data/data_MaxQuant/ABRF_maxquant_quantile_&#39;) Draw Profile plots of protein P55249, for both cases above and compare. dataProcessPlots(data = quant.maxquant, type=&quot;Profileplot&quot;, featureName=&quot;NA&quot;, width=7, height=7, which.Protein = &#39;P55249&#39;, address=&quot;data/data_MaxQuant/ABRF_maxquant_equalMed_P55249_&quot;) dataProcessPlots(data = quant.maxquant.quantile, type=&quot;Profileplot&quot;, featureName=&quot;NA&quot;, width=7, height=7, which.Protein = &#39;P55249&#39;, address=&quot;data/data_MaxQuant/ABRF_maxquant_quantile_P55249_&quot;) 2.2.3 dataProcess with OpenMS data load(file=&#39;data/data_OpenMS/input.openms.rda&#39;) head(input.openms) ## ProteinName PeptideSequence PrecursorCharge FragmentIon ## 1 sp|D6VTK4|STE2_YEAST EGEVEPVDMYTPDTAADEEARK 3 NA ## 2 sp|D6VTK4|STE2_YEAST FYPGTLSSFQTDSINNDAK 2 NA ## 3 sp|D6VTK4|STE2_YEAST IGPFADASYK 2 NA ## 4 sp|D6VTK4|STE2_YEAST NQFYQLPTPTSSK 2 NA ## 5 sp|D6VTK4|STE2_YEAST TFVSETADDIEK 2 NA ## 6 sp|D6VTK4|STE2_YEAST TNTITSDFTTSTDR 2 NA ## ProductCharge IsotopeLabelType Condition BioReplicate Run Intensity ## 1 0 L 1 1 1 64757900 ## 2 0 L 1 1 1 38852700 ## 3 0 L 1 1 1 73225800 ## 4 0 L 1 1 1 63139900 ## 5 0 L 1 1 1 NA ## 6 0 L 1 1 1 58905300 sum(is.na(input.openms$Intensity)) ## [1] 21962 sum(!is.na(input.openms$Intensity) &amp; input.openms$Intensity==0) ## [1] 0 Note! OpenMS output has only NA. censoredInt=‘NA’ should be used for OpenMS output. Challenges Try dataProcess with equalize normalization for OpenMS output. (input.openms.rda from section 1) quant.openms &lt;- dataProcess(raw = input.openms, logTrans=2, #normalization = &#39;quantile&#39;, summaryMethod = &#39;TMP&#39;, MBimpute=TRUE, censoredInt=&#39;NA&#39;, cutoffCensored=&#39;minFeature&#39;, maxQuantileforCensored = 0.999) Try dataProcess with quantile normalization for OpenMS output. (input.openms.rda from section 1) quant.openms.quantile &lt;- dataProcess(raw = input.openms, logTrans=2, normalization = &#39;quantile&#39;, summaryMethod = &#39;TMP&#39;, MBimpute=TRUE, censoredInt=&#39;NA&#39;, cutoffCensored=&#39;minFeature&#39;, maxQuantileforCensored = 0.999) Draw Profile plots of protein sp|P55249|ZRT4_YEAST, for both cases above and compare. dataProcessPlots(data = quant.openms, type=&quot;Profileplot&quot;, featureName=&quot;NA&quot;, width=7, height=7, which.Protein = &#39;sp|P55249|ZRT4_YEAST&#39;, address=&quot;data/data_OpenMS/ABRF_openms_equalMed_P55249_&quot;) dataProcessPlots(data = quant.openms.quantile, type=&quot;Profileplot&quot;, featureName=&quot;NA&quot;, width=7, height=7, which.Protein = &#39;sp|P55249|ZRT4_YEAST&#39;, address=&quot;data/data_OpenMS/ABRF_openms_quantile_P55249_&quot;) 2.2.4 dataProcess with Progenesis data load(file=&#39;data/data_Progenesis/input.progenesis.rda&#39;) head(input.progenesis) ## ProteinName PeptideModifiedSequence PrecursorCharge ## 1 sp|A5Z2X5|YP010_YEAST LTGNPELSSLDEVLAK 2 ## 2 sp|A5Z2X5|YP010_YEAST RPAQLLL[N-term] nTerm+42.0106 2 ## 3 sp|D6VTK4|STE2_YEAST EGEVEPVDMYTPDTAADEEARK 3 ## 4 sp|D6VTK4|STE2_YEAST FYPGTLSSFQTDSINNDAK 2 ## 5 sp|D6VTK4|STE2_YEAST IGPFADASYK 2 ## 6 sp|O13297|CET1_YEAST IAGNAVGSVVK 2 ## FragmentIon ProductCharge IsotopeLabelType Condition BioReplicate ## 1 NA NA L Condition1 1 ## 2 NA NA L Condition1 1 ## 3 NA NA L Condition1 1 ## 4 NA NA L Condition1 1 ## 5 NA NA L Condition1 1 ## 6 NA NA L Condition1 1 ## Run Intensity ## 1 JD_06232014_sample1_B 2550357.3 ## 2 JD_06232014_sample1_B 865491.8 ## 3 JD_06232014_sample1_B 3767734.3 ## 4 JD_06232014_sample1_B 2591735.2 ## 5 JD_06232014_sample1_B 2301483.1 ## 6 JD_06232014_sample1_B 415181.8 sum(is.na(input.progenesis$Intensity)) ## [1] 0 sum(!is.na(input.progenesis$Intensity) &amp; input.progenesis$Intensity==0) ## [1] 418 Note! Progenesis output has only 0. censoredInt=‘0’ should be used for Progenesis output. Challenges Try dataProcess with equalize normalization for Progenesis output. (input.progenesis.rda from section 1) quant.progenesis &lt;- dataProcess(raw = input.progenesis, logTrans=2, #normalization = &#39;quantile&#39;, summaryMethod = &#39;TMP&#39;, MBimpute=TRUE, censoredInt=&#39;0&#39;, cutoffCensored=&#39;minFeature&#39;, maxQuantileforCensored = 0.999) Try dataProcess with quantile normalization for Progenesis output. (input.progenesis.rda from section 1) quant.progenesis.quantile &lt;- dataProcess(raw = input.progenesis, logTrans=2, normalization = &#39;quantile&#39;, summaryMethod = &#39;TMP&#39;, MBimpute=TRUE, censoredInt=&#39;0&#39;, cutoffCensored=&#39;minFeature&#39;, maxQuantileforCensored = 0.999) Draw Profile plots of protein sp|P55249|ZRT4_YEAST, for both cases above and compare. dataProcessPlots(data = quant.progenesis, type=&quot;Profileplot&quot;, featureName=&quot;NA&quot;, width=7, height=7, which.Protein = &#39;sp|P55249|ZRT4_YEAST&#39;, address=&quot;data/data_Progenesis/ABRF_progenesis_equalMed_P55249_&quot;) dataProcessPlots(data = quant.progenesis.quantile, type=&quot;Profileplot&quot;, featureName=&quot;NA&quot;, width=7, height=7, which.Protein = &#39;sp|P55249|ZRT4_YEAST&#39;, address=&quot;data/data_Progenesis/ABRF_progenesis_quantile_P55249_&quot;) Compare profile plots from MaxQuant data. 2.3 Differential abundance and sample size calculation 2.3.1 Inference and future design of experiment with Skyline output 2.3.1.1 Load the processed data (output of dataProcess) of Skyline output load(file=&#39;data/data_Skyline/quant.skyline.rda&#39;) 2.3.1.2 Finding differentially abundant proteins across conditions 2.3.1.2.1 Assign contrast matrix After we normalized the data and summarized each protein’s behaviour across conditions in dataProcess step, we are all set to compare protein changes between groups of conditions. Within MSstats we can do this with the groupComparison function, which takes as input the output of the dataProcess function. ?groupComparison We have to tell groupComparison which are the conditions we would like to compare. You can make your contrast.matrix in R in a text editor. We define our contrast matrix by adding a column for every condition, in alphabetical order. We add a row for every comparison we would like to make between groups of conditions. 0 is for conditions we would like to ignore. 1 is for conditions we would like to put in the numerator of the ratio or fold-change. -1 is for conditions we would like to put in the denumerator of the ratio or fold-change. If you have multiple groups, you can assign any gruop comparisons you are interested in. For example, if you have 4 different conditions, Condition1, Condition2, Condition3, Condition4, there are many possible comparisons. # check unique conditions and check order of condition information # In this case, Disease and Healthy unique(quant.skyline$ProcessedData$GROUP_ORIGINAL) ## [1] Condition1 Condition2 Condition3 Condition4 ## Levels: Condition1 Condition2 Condition3 Condition4 comparison1&lt;-matrix(c(-1,1,0,0),nrow=1) comparison2&lt;-matrix(c(-1,0,1,0),nrow=1) comparison&lt;-rbind(comparison1, comparison2) row.names(comparison)&lt;-c(&quot;C2-C1&quot;,&quot;C3-C1&quot;) comparison ## [,1] [,2] [,3] [,4] ## C2-C1 -1 1 0 0 ## C3-C1 -1 0 1 0 Challenges Make the matrix, named comparison, for all 6 paired comparision among 4 conditions (condition1, condition2, condition3, condition4) unique(quant.skyline$ProcessedData$GROUP_ORIGINAL) ## [1] Condition1 Condition2 Condition3 Condition4 ## Levels: Condition1 Condition2 Condition3 Condition4 comparison1&lt;-matrix(c(-1,1,0,0),nrow=1) comparison2&lt;-matrix(c(-1,0,1,0),nrow=1) comparison3&lt;-matrix(c(-1,0,0,1),nrow=1) comparison4&lt;-matrix(c(0,-1,1,0),nrow=1) comparison5&lt;-matrix(c(0,-1,0,1),nrow=1) comparison6&lt;-matrix(c(0,0,-1,1),nrow=1) comparison&lt;-rbind(comparison1, comparison2, comparison3, comparison4, comparison5, comparison6) row.names(comparison)&lt;-c(&quot;C2-C1&quot;,&quot;C3-C1&quot;,&quot;C4-C1&quot;,&quot;C3-C2&quot;,&quot;C4-C2&quot;,&quot;C4-C3&quot;) comparison ## [,1] [,2] [,3] [,4] ## C2-C1 -1 1 0 0 ## C3-C1 -1 0 1 0 ## C4-C1 -1 0 0 1 ## C3-C2 0 -1 1 0 ## C4-C2 0 -1 0 1 ## C4-C3 0 0 -1 1 2.3.1.2.2 Comparing conditions with groupComparison groupComparison uses the run-level summarized data ($RunlevelData from dataProcess function) for hypothesis testing. test.skyline &lt;- groupComparison(contrast.matrix=comparison, data=quant.skyline) Let’s check the output. class(test.skyline) ## [1] &quot;list&quot; names(test.skyline) ## [1] &quot;ComparisonResult&quot; &quot;ModelQC&quot; &quot;fittedmodel&quot; # Show test result # Label : which comparison is used # log2FC : estimated log2 fold change between Diseased and Healthy # adj.pvalue : adjusted p value # issue : detect whether this protein has any issue for comparison # such as, there is measurement in certain group, or no measurement at all. # MissingPercentage : the number of missing intensities/total number of intensities # in conditions your are interested in for comparison # ImputationPercentage : the number of imputed intensities/total number of intensities # in conditions your are interested in for comparison head(test.skyline$ComparisonResult) ## Protein Label log2FC SE Tvalue DF ## 1 sp|D6VTK4|STE2_YEAST C2-C1 0.06094263 0.10304517 0.5914167 8 ## 2 sp|O13297|CET1_YEAST C2-C1 -0.11024579 0.07589698 -1.4525714 8 ## 3 sp|O13329|FOB1_YEAST C2-C1 -0.16114268 0.29273717 -0.5504688 8 ## 4 sp|O13539|THP2_YEAST C2-C1 -0.43646953 0.83013182 -0.5257834 8 ## 5 sp|O13547|CCW14_YEAST C2-C1 -0.05679619 0.14506388 -0.3915254 8 ## 6 sp|O13563|RPN13_YEAST C2-C1 -0.16850033 0.09496183 -1.7744006 8 ## pvalue adj.pvalue issue MissingPercentage ImputationPercentage ## 1 0.5705706 0.9983122 NA 0 0 ## 2 0.1844096 0.9983122 NA 0 0 ## 3 0.5970289 0.9983122 NA 0 0 ## 4 0.6132973 0.9983122 NA 0 0 ## 5 0.7056311 0.9983122 NA 0 0 ## 6 0.1139193 0.9983122 NA 0 0 # After fitting linear model, residuals and fitted values can be shown. head(test.skyline$ModelQC) ## RUN PROTEIN ABUNDANCE NumMeasuredFeature MissingPercentage ## 1: 1 sp|D6VTK4|STE2_YEAST 26.95958 7 0 ## 2: 2 sp|D6VTK4|STE2_YEAST 26.78088 7 0 ## 3: 3 sp|D6VTK4|STE2_YEAST 26.68074 7 0 ## 4: 4 sp|D6VTK4|STE2_YEAST 26.98540 7 0 ## 5: 5 sp|D6VTK4|STE2_YEAST 26.90384 7 0 ## 6: 6 sp|D6VTK4|STE2_YEAST 26.71479 7 0 ## more50missing NumImputedFeature originalRUN GROUP ## 1: FALSE 0 JD_06232014_sample1_B.raw 1 ## 2: FALSE 0 JD_06232014_sample1_C.raw 1 ## 3: FALSE 0 JD_06232014_sample1-A.raw 1 ## 4: FALSE 0 JD_06232014_sample2_A.raw 2 ## 5: FALSE 0 JD_06232014_sample2_B.raw 2 ## 6: FALSE 0 JD_06232014_sample2_C.raw 2 ## GROUP_ORIGINAL SUBJECT_ORIGINAL SUBJECT_NESTED SUBJECT residuals ## 1: Condition1 1 1.1 1 0.15251179 ## 2: Condition1 1 1.1 1 -0.02618545 ## 3: Condition1 1 1.1 1 -0.12632634 ## 4: Condition2 2 2.4 4 0.11739159 ## 5: Condition2 2 2.4 4 0.03582686 ## 6: Condition2 2 2.4 4 -0.15321844 ## fitted ## 1: 26.80707 ## 2: 26.80707 ## 3: 26.80707 ## 4: 26.86801 ## 5: 26.86801 ## 6: 26.86801 # Fitted model per protein head(test.skyline$fittedmodel) ## [[1]] ## ## Call: ## lm(formula = ABUNDANCE ~ GROUP, data = data2) ## ## Coefficients: ## (Intercept) GROUP2 GROUP3 GROUP4 ## 26.80707 0.06094 -0.16303 -0.11015 ## ## ## [[2]] ## ## Call: ## lm(formula = ABUNDANCE ~ GROUP, data = data2) ## ## Coefficients: ## (Intercept) GROUP2 GROUP3 GROUP4 ## 24.69673 -0.11025 -0.13596 -0.08799 ## ## ## [[3]] ## ## Call: ## lm(formula = ABUNDANCE ~ GROUP, data = data2) ## ## Coefficients: ## (Intercept) GROUP2 GROUP3 GROUP4 ## 23.6136 -0.1611 0.1294 -0.3427 ## ## ## [[4]] ## ## Call: ## lm(formula = ABUNDANCE ~ GROUP, data = data2) ## ## Coefficients: ## (Intercept) GROUP2 GROUP3 GROUP4 ## 26.3935 -0.4365 -0.4232 -0.4941 ## ## ## [[5]] ## ## Call: ## lm(formula = ABUNDANCE ~ GROUP, data = data2) ## ## Coefficients: ## (Intercept) GROUP2 GROUP3 GROUP4 ## 27.04062 -0.05680 -0.28259 -0.08648 ## ## ## [[6]] ## ## Call: ## lm(formula = ABUNDANCE ~ GROUP, data = data2) ## ## Coefficients: ## (Intercept) GROUP2 GROUP3 GROUP4 ## 26.17882 -0.16850 -0.06754 -0.20791 test.skyline$fittedmodel[[1]] ## ## Call: ## lm(formula = ABUNDANCE ~ GROUP, data = data2) ## ## Coefficients: ## (Intercept) GROUP2 GROUP3 GROUP4 ## 26.80707 0.06094 -0.16303 -0.11015 2.3.1.2.3 Save the comparison result Let’s save the testing result as rdata and .csv file. Skyline.result &lt;- test.skyline$ComparisonResult save(Skyline.result, file=&#39;data/data_Skyline/Skyline.result.rda&#39;) write.csv(Skyline.result, file=&#39;data/data_Skyline/testResult_ABRF_skyline.csv&#39;) 2.3.1.2.4 subset of significant comparisons Let’s inspect the results to see what proteins are changing significantly between Diseased and Healthy. head(Skyline.result) ## Protein Label log2FC SE Tvalue DF ## 1 sp|D6VTK4|STE2_YEAST C2-C1 0.06094263 0.10304517 0.5914167 8 ## 2 sp|O13297|CET1_YEAST C2-C1 -0.11024579 0.07589698 -1.4525714 8 ## 3 sp|O13329|FOB1_YEAST C2-C1 -0.16114268 0.29273717 -0.5504688 8 ## 4 sp|O13539|THP2_YEAST C2-C1 -0.43646953 0.83013182 -0.5257834 8 ## 5 sp|O13547|CCW14_YEAST C2-C1 -0.05679619 0.14506388 -0.3915254 8 ## 6 sp|O13563|RPN13_YEAST C2-C1 -0.16850033 0.09496183 -1.7744006 8 ## pvalue adj.pvalue issue MissingPercentage ImputationPercentage ## 1 0.5705706 0.9983122 NA 0 0 ## 2 0.1844096 0.9983122 NA 0 0 ## 3 0.5970289 0.9983122 NA 0 0 ## 4 0.6132973 0.9983122 NA 0 0 ## 5 0.7056311 0.9983122 NA 0 0 ## 6 0.1139193 0.9983122 NA 0 0 # select subset of rows with adj.pvalue &lt; 0.05 SignificantProteins &lt;- Skyline.result[Skyline.result$adj.pvalue &lt; 0.05, ] nrow(SignificantProteins) ## [1] 28 # select subset of rows with adj.pvalue &lt; 0.05 and log2FC &gt; 2 SignificantProteinsUpInDiseased &lt;- SignificantProteins[SignificantProteins$log2FC &gt; 2 ,] nrow(SignificantProteinsUpInDiseased) ## [1] 14 2.3.1.3 Visualization of differentially abundant proteins ?groupComparisonPlots 2.3.1.3.1 Volcano plot Volcano plots allow us to visually separate strong changes, which are not significant, from strong and significant changes. Look for these subjects in the upper right and upper left quadrants of the plot. Protein name will be shown only for siginificant proteins. groupComparisonPlots(data = Skyline.result, type = &#39;VolcanoPlot&#39;, address = &#39;data/data_Skyline/testResult_ABRF_skyline_&#39;) We can set up estimated fold change cutoff. groupComparisonPlots(data = Skyline.result, type = &#39;VolcanoPlot&#39;, sig = 0.05, FCcutoff = 2^2, address = &#39;data/data_Skyline/testResult_ABRF_skyline_FCcutoff4_&#39;) 2.3.1.3.2 Comparison plot Comparison plots illustrate model-based estimates of log-fold changes, and the associated uncertainty, in several comparisons of conditions for one protein. X-axis is the comparison of interest. Y-axis is the log fold change. The dots are the model-based estimates of log-fold change, and the error bars are the model-based 95% confidence intervals (the option sig can be used to change the significance level of significance). For simplicity, the confidence intervals are adjusted for multiple comparisons within protein only, using the Bonferroni approach. For proteins with N comparisons, the individual confidence intervals are at the level of 1-sig/N. groupComparisonPlots(Skyline.result, type=&quot;ComparisonPlot&quot;, address=&quot;data/data_Skyline/testResult_ABRF_skyline_&quot;) Let’s check the comparison result for protein sp|P44015|VAC2_YEAST. Skyline.result[Skyline.result$Protein == &#39;sp|P44015|VAC2_YEAST&#39;, ] ## Protein Label log2FC SE Tvalue DF ## 1756 sp|P44015|VAC2_YEAST C2-C1 -0.2287384 0.3108677 -0.7358063 8 ## 4774 sp|P44015|VAC2_YEAST C3-C1 -2.9716852 0.3108677 -9.5593254 8 ## 7792 sp|P44015|VAC2_YEAST C4-C1 -5.2574901 0.3108677 -16.9123090 8 ## 10810 sp|P44015|VAC2_YEAST C3-C2 -2.7429468 0.3108677 -8.8235190 8 ## 13828 sp|P44015|VAC2_YEAST C4-C2 -5.0287517 0.3108677 -16.1765027 8 ## 16846 sp|P44015|VAC2_YEAST C4-C3 -2.2858049 0.3108677 -7.3529837 8 ## pvalue adj.pvalue issue MissingPercentage ## 1756 4.828617e-01 0.9983122047 NA 0 ## 4774 1.187124e-05 0.0089568526 NA 0 ## 7792 1.515151e-07 0.0001143182 NA 0 ## 10810 2.143047e-05 0.0129354325 NA 0 ## 13828 2.143125e-07 0.0001293590 NA 0 ## 16846 7.970992e-05 0.0601411333 NA 0 ## ImputationPercentage ## 1756 0 ## 4774 0 ## 7792 0 ## 10810 0 ## 13828 0 ## 16846 0 2.3.1.4 Planning future experimental designs This last analysis step views the dataset as a pilot study of a future experiment, utilizes its variance components, and calculates the minimal number of replicates required in a future experiment to achieve the desired statistical power. The calculation is performed by the function designSampleSize, which takes as input the fitted model in groupComparison. Sample size calculation assumes same experimental design (i.e. group comparison, time course or paired design) as in the current dataset, and uses the model fit to estimate the median variance components across all the proteins. Finally, sample size calculation assumes that a large proportion of proteins (specifically, 99%) will not change in abundance in the future experiment. This assumption also provides conservative results. Using the estimated variance components, the function relates the number of biological replicates per condition (numSample, rounded to 0 decimal), average statistical power across all the proteins (power), minimal fold change that we would like to detect (can be specified as a range, e.g. desiredFC=c(1.1, 2)), and the False Discovery Rate (FDR). The user should specify all these quantities but one, and the function will solve for the remainder. The quantity to solve for should be set to = TRUE. ?designSampleSize 2.3.1.4.1 Calculating statistical power # calculate the power test.power &lt;- designSampleSize(data = test.skyline$fittedmodel, desiredFC = c(1.1, 1.6), FDR = 0.05, power = TRUE, numSample = 3) test.power ## desiredFC numSample FDR power CV ## 1 1.100 3 0.05 0.01 0.010 ## 2 1.125 3 0.05 0.01 0.010 ## 3 1.150 3 0.05 0.01 0.010 ## 4 1.175 3 0.05 0.01 0.010 ## 5 1.200 3 0.05 0.04 0.009 ## 6 1.225 3 0.05 0.10 0.009 ## 7 1.250 3 0.05 0.20 0.009 ## 8 1.275 3 0.05 0.33 0.009 ## 9 1.300 3 0.05 0.47 0.009 ## 10 1.325 3 0.05 0.59 0.008 ## 11 1.350 3 0.05 0.70 0.008 ## 12 1.375 3 0.05 0.79 0.008 ## 13 1.400 3 0.05 0.86 0.008 ## 14 1.425 3 0.05 0.91 0.008 ## 15 1.450 3 0.05 0.94 0.008 ## 16 1.475 3 0.05 0.97 0.008 ## 17 1.500 3 0.05 0.98 0.007 ## 18 1.525 3 0.05 0.99 0.007 ## 19 1.550 3 0.05 0.99 0.007 ## 20 1.575 3 0.05 0.99 0.007 ## 21 1.600 3 0.05 0.99 0.007 2.3.1.4.2 Visualizing the relationship between desired fold-change and power designSampleSizePlots(data = test.power) 2.3.1.4.3 Designing sample size for desired fold-change # Minimal number of biological replicates per condition samplesize &lt;- designSampleSize(data = test.skyline$fittedmodel, desiredFC = c(1.1, 1.6), FDR = 0.05, power = 0.9, numSample = TRUE) samplesize ## desiredFC numSample FDR power CV ## 1 1.100 40 0.05 0.9 0.001 ## 2 1.125 26 0.05 0.9 0.001 ## 3 1.150 19 0.05 0.9 0.002 ## 4 1.175 14 0.05 0.9 0.002 ## 5 1.200 11 0.05 0.9 0.003 ## 6 1.225 9 0.05 0.9 0.003 ## 7 1.250 7 0.05 0.9 0.004 ## 8 1.275 6 0.05 0.9 0.004 ## 9 1.300 5 0.05 0.9 0.005 ## 10 1.325 5 0.05 0.9 0.005 ## 11 1.350 4 0.05 0.9 0.006 ## 12 1.375 4 0.05 0.9 0.006 ## 13 1.400 3 0.05 0.9 0.008 ## 14 1.425 3 0.05 0.9 0.008 ## 15 1.450 3 0.05 0.9 0.008 ## 16 1.475 2 0.05 0.9 0.011 ## 17 1.500 2 0.05 0.9 0.011 ## 18 1.525 2 0.05 0.9 0.011 ## 19 1.550 2 0.05 0.9 0.011 ## 20 1.575 2 0.05 0.9 0.011 ## 21 1.600 2 0.05 0.9 0.010 2.3.1.4.4 Visualizing the relationship between desired fold-change and mininum sample size number designSampleSizePlots(data = samplesize) 2.3.1.5 Protein subject quantification If there is no technical replicate, subject (or sample) quantification should be the same as run-level summarization. If there are technical replicates, subjet-level summarization(quantification) with run-level summarization will be useful for downstream analysis, such as classification. ?quantification sampleQuant &lt;- quantification(quant.skyline) head(sampleQuant) ## Protein Condition1_1 Condition2_2 Condition3_3 ## 1 sp|D6VTK4|STE2_YEAST 26.60824 26.79392 26.53057 ## 2 sp|O13297|CET1_YEAST 24.71754 24.57784 24.62606 ## 3 sp|O13329|FOB1_YEAST 23.47021 23.43389 23.73769 ## 4 sp|O13539|THP2_YEAST 27.38549 25.90566 25.91828 ## 5 sp|O13547|CCW14_YEAST 27.11584 26.91263 26.75494 ## 6 sp|O13563|RPN13_YEAST 26.17001 26.00997 26.11441 ## Condition4_4 ## 1 26.60602 ## 2 24.64876 ## 3 23.16636 ## 4 25.91791 ## 5 26.98071 ## 6 26.05425 groupQuant &lt;- quantification(quant.skyline, type=&#39;Group&#39;) head(groupQuant) ## Protein Condition1 Condition2 Condition3 Condition4 ## 1 sp|D6VTK4|STE2_YEAST 26.60824 26.79392 26.53057 26.60602 ## 2 sp|O13297|CET1_YEAST 24.71754 24.57784 24.62606 24.64876 ## 3 sp|O13329|FOB1_YEAST 23.47021 23.43389 23.73769 23.16636 ## 4 sp|O13539|THP2_YEAST 27.38549 25.90566 25.91828 25.91791 ## 5 sp|O13547|CCW14_YEAST 27.11584 26.91263 26.75494 26.98071 ## 6 sp|O13563|RPN13_YEAST 26.17001 26.00997 26.11441 26.05425 2.3.1.6 msstats.log and sessionInfo.txt These two files are important to keep the records of package versions and options in functions. 2.3.2 Inference and future design of experiment with Skyline output Challenges Load the processed data (output of dataProcess from section 2 of MaxQuant output and 1) find the differentially abundant comparisons using groupComparison with the same comparison matrix, 2) draw volcano plot with output of groupComparison, and 3) draw comparison plot with output of groupComparison with MaxQuant output. and Check the comparison plot for the protein, P55249. load(file=&#39;data/data_MaxQuant/quant.maxquant.rda&#39;) test.maxquant &lt;- groupComparison(contrast.matrix=comparison, data=quant.maxquant) MaxQuant.result &lt;- test.maxquant$ComparisonResult write.csv(MaxQuant.result, file=&#39;data/data_MaxQuant/testResult_ABRF_maxquant.csv&#39;) groupComparisonPlots(data = MaxQuant.result, type = &#39;VolcanoPlot&#39;, address = &#39;data/data_MaxQuant/testResult_ABRF_maxquant_&#39;) groupComparisonPlots(data = MaxQuant.result, type = &#39;ComparisonPlot&#39;, which.Protein = &#39;P55249&#39;, address = &#39;data/data_MaxQuant/testResult_ABRF_maxquant_&#39;) 2.3.3 Inference and future design of experiment with OpenMS output Challenges Load the processed data (output of dataProcess from section 2 of OpenMS output and 1) find the differentially abundant comparisons using groupComparison with the same comparison matrix, 2) draw volcano plot with output of groupComparison, and 3) draw comparison plot with output of groupComparison with OpenMS output. and Check the comparison plot for the protein, sp|P55249|ZRT4_YEAST. load(file=&#39;data/data_OpenMS/quant.openms.rda&#39;) test.openms &lt;- groupComparison(contrast.matrix=comparison, data=quant.openms) OpenMS.result &lt;- test.openms$ComparisonResult write.csv(OpenMS.result, file=&#39;data/data_OpenMS/testResult_ABRF_openms.csv&#39;) groupComparisonPlots(data = MaxQuant.result, type = &#39;VolcanoPlot&#39;, address = &#39;data/data_OpenMS/testResult_ABRF_openms_&#39;) groupComparisonPlots(data = MaxQuant.result, type = &#39;ComparisonPlot&#39;, which.Protein = &#39;sp|P55249|ZRT4_YEAST&#39;, address = &#39;data/data_OpenMS/testResult_ABRF_openms_&#39;) Here is the experimental design for ABRF 2015 study. "],
["section-9-msstatstmt.html", "Chapter 3 Section 9: MSstatsTMT 3.1 Introductioin to data and preprocessing 3.2 Summarization, normalization and significance analysis", " Chapter 3 Section 9: MSstatsTMT 3.1 Introductioin to data and preprocessing 3.1.1 Objective Preprocessing steps to make required input format for MSstatsTMT from output from diverse output of spectral processing and peptide quantification tools. Make annotation file, based on experimental design. 3.1.2 Data Controlled mixtures: Sigma UPS1 48 protein-mix were spiked at 4 different ratio into a SILAC-labelled HeLa lysate. The mixtures were measured by TMT 10-plexes. the peptide quantification data of controlled mixtures, processed by Proteome Discoverer and MaxQuant. 3.1.3 Load MSstatsTMT Load MSstatsTMT first. Then you are ready to start MSstats. # install MSstatsTMT from bioconductor # if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) # install.packages(&quot;BiocManager&quot;) # BiocManager::install(&quot;MSstatsTMT&quot;) library(MSstatsTMT) # make sure it is version 1.2.1 ## ## Attaching package: &#39;MSstatsTMT&#39; ## The following object is masked _by_ &#39;.GlobalEnv&#39;: ## ## proteinGroups ?MSstatsTMT *** 3.1.4 Allowable data formats MSstatsTMT performs statistical analysis steps, that follow peptide identification and quantitation. Therefore, input to MSstatsTMT is the output of other software tools (such as Proteome Discoverer, MaxQuant and so on) that read raw spectral files , identify and quantify peptide ions. The preferred structure of data for use in MSstatsTMT is a .csv file in a long format with at least 10 columns representing the following variables: ProteinName, PeptideSequence, Charge, PSM, Channel, Condition, BioReplicate, Mixture, TechRepMixture, Intensity. The variable names are fixed, but are case-insensitive. ## ProteinName PeptideSequence Charge ## 1 P04406 [K].lISWYDNEFGYSNR.[V] 2 ## 2 Q9NSD9 [K].irPFAVAAVLr.[N] 3 ## 3 P04406 [K].lVINGNPITIFQErDPSk.[I] 3 ## 4 P04406 [R].vVDLmAHMASkE.[-] 3 ## 5 P06576 [R].dQEGQDVLLFIDNIFR.[F] 3 ## 6 P06576 [R].iPSAVGYQPTLATDMGTMQEr.[I] 3 ## PSM Mixture TechRepMixture ## 1 [K].lISWYDNEFGYSNR.[V]_2 Mixture1 1 ## 2 [K].irPFAVAAVLr.[N]_3 Mixture1 1 ## 3 [K].lVINGNPITIFQErDPSk.[I]_3 Mixture1 1 ## 4 [R].vVDLmAHMASkE.[-]_3 Mixture1 1 ## 5 [R].dQEGQDVLLFIDNIFR.[F]_3 Mixture1 1 ## 6 [R].iPSAVGYQPTLATDMGTMQEr.[I]_3 Mixture1 1 ## Run Channel Condition ## 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## 6 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## BioReplicate Intensity ## 1 Mixture1_Norm 8348.351 ## 2 Mixture1_Norm 28327.492 ## 3 Mixture1_Norm 1275010.965 ## 4 Mixture1_Norm 80589.877 ## 5 Mixture1_Norm 2231.389 ## 6 Mixture1_Norm 144854.307 Let’s start preprocessing steps to make required input format for MSstatsTMT from output from diverse output of peptide quantification tools. 3.1.5 Proteome Discoverer output 3.1.5.1 Read data The required input data is the PSM-level data generated by Proteome Discoverer 2.2. We first load and access the dataset processed by Proteome Discoverer. The file name is ‘spikedin_PSMs.txt’. # Read output from Proteome Discoverer raw.pd &lt;- read.delim(file=&quot;data/data_ProteomeDiscoverer_TMT/spikedin_PSMs.txt&quot;) # Check the column names colnames(raw.pd) ## [1] &quot;Checked&quot; &quot;Confidence&quot; ## [3] &quot;Identifying.Node&quot; &quot;PSM.Ambiguity&quot; ## [5] &quot;Annotated.Sequence&quot; &quot;Modifications&quot; ## [7] &quot;Marked.as&quot; &quot;X..Protein.Groups&quot; ## [9] &quot;X..Proteins&quot; &quot;Master.Protein.Accessions&quot; ## [11] &quot;Master.Protein.Descriptions&quot; &quot;Protein.Accessions&quot; ## [13] &quot;Protein.Descriptions&quot; &quot;X..Missed.Cleavages&quot; ## [15] &quot;Charge&quot; &quot;DeltaScore&quot; ## [17] &quot;DeltaCn&quot; &quot;Rank&quot; ## [19] &quot;Search.Engine.Rank&quot; &quot;m.z..Da.&quot; ## [21] &quot;MH...Da.&quot; &quot;Theo..MH...Da.&quot; ## [23] &quot;DeltaM..ppm.&quot; &quot;Deltam.z..Da.&quot; ## [25] &quot;Activation.Type&quot; &quot;MS.Order&quot; ## [27] &quot;Isolation.Interference....&quot; &quot;Average.Reporter.S.N&quot; ## [29] &quot;Ion.Inject.Time..ms.&quot; &quot;RT..min.&quot; ## [31] &quot;First.Scan&quot; &quot;Spectrum.File&quot; ## [33] &quot;File.ID&quot; &quot;Abundance..126&quot; ## [35] &quot;Abundance..127N&quot; &quot;Abundance..127C&quot; ## [37] &quot;Abundance..128N&quot; &quot;Abundance..128C&quot; ## [39] &quot;Abundance..129N&quot; &quot;Abundance..129C&quot; ## [41] &quot;Abundance..130N&quot; &quot;Abundance..130C&quot; ## [43] &quot;Abundance..131&quot; &quot;Quan.Info&quot; ## [45] &quot;Ions.Score&quot; &quot;Identity.Strict&quot; ## [47] &quot;Identity.Relaxed&quot; &quot;Expectation.Value&quot; ## [49] &quot;Percolator.q.Value&quot; &quot;Percolator.PEP&quot; The column names are differently from required input. Let’s do preliminary check for this input. # total number of unique protein name proteins &lt;- unique(raw.pd$Protein.Accessions) length(proteins) ## [1] 50 # show the spiked-in proteins proteins[grepl(&quot;ups&quot;,proteins)] ## [1] P02788ups P62988ups P68871ups P02741ups P01008ups ## [6] P10636-8ups P02787ups P02753ups P00915ups P05413ups ## [11] P01344ups P01579ups P01031ups P01375ups P02144ups ## 50 Levels: A1L0T0 O00625 O60427 P00915ups P01008ups ... Q9Y6C9 # total number of unique peptide names length(unique(raw.pd$Annotated.Sequence)) ## [1] 461 # unique Spectrum.File, which is TMT run. unique(raw.pd$Spectrum.File) ## [1] 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw ## [2] 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_02.raw ## [3] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw ## [4] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_02.raw ## [5] 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_02.raw ## [6] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_01.raw ## [7] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_02.raw ## [8] 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_03.raw ## [9] 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_02.raw ## [10] 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_01.raw ## [11] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_03.raw ## [12] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_03.raw ## [13] 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_01.raw ## [14] 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_03.raw ## [15] 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_01.raw ## 15 Levels: 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw ... 3.1.5.2 Prepare annotation file MSstatsTMT can make inference for group comparison design. In a group comparison design, the conditions (e.g., disease states) are profiled across non-overlapping sets of biological replicates (i.e., subjects). In this example there are 4 conditions, 0.125, 0.5, 0.667, 1 (in general the number of conditions can vary). There are 2 subjects per condition per MS run (in general an equal number of replicates per condition is not required). Besides 2 pooled control replicates per run for across TMT-plex normalizations. Totally, each mixture has 10 replicates. There are 5 mixtures and each mixture has 3 technical replicate runs (in general technical replicates are not required, and their number per sample may vary). Overall, in this example there are 5 × 3 = 15 mass spectrometry runs and 5 × 3 x 10 = 150 replicates. Mixture Run 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_03.raw 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_02.raw 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_03.raw 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_02.raw 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_01.raw 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_02.raw 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_03.raw 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_01.raw 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_02.raw 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_03.raw Here show run 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw as an example, Run Channel BioReplicate Condition 1 X127C 1.X127C 0.125 1 X129N 1.X129N 0.125 1 X128N 1.X128N 0.5 1 X129C 1.X129C 0.5 1 X127N 1.X127N 0.667 1 X130C 1.X130C 0.667 1 X128C 1.X128C 1 1 X130N 1.X130N 1 1 X126 1.X126 Norm 1 X131 1.X131 Norm The most important is that 1) Run is not order of spectral acquisition, but just unique MS run ID 2) if normalization between runs need to be done, then each run must have at least one Norm channel 3) Channel column in the annotation file should match with the corresponding channel names in in output of Proteome Discoverer 4) Spectrum.File in the PSM output of Proteome Discoverer should be the Run column in the annotation file 5) If one channel of one mixture doesn’t have sample, put None under Condition and BioReplicate column . Annotation information is required to fill in Condition, TechRepMixture, Mixture and BioReplicate for corresponding Run and Channel information. Users have to prepare as csv or txt file like ‘PD_Annotation.csv’, which includes Run, Channel, Condition, BioReplicate, TechRepMixture and Mixture information, and load it in R. annot.pd &lt;- read.csv(file=&quot;data/data_ProteomeDiscoverer_TMT/PD_Annotation.csv&quot;) head(annot.pd) ## Run Mixture TechRepMixture ## 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 6 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## Fraction Channel Condition BioReplicate ## 1 F1 126 Norm Norm ## 2 F1 127N 0.125 0.125 ## 3 F1 127C 0.667 0.667 ## 4 F1 128N 1 1 ## 5 F1 128C 0.5 0.5 ## 6 F1 129N 0.5 0.5 3.1.5.2.1 Prepare the file with run information Raw Spectrum file name in the output of peptide quantification tool should be the Run information in the annotation file. Let’s start with Spectrum.File in PSM output of Proteome Discoverer. runs &lt;- unique(raw.pd$Spectrum.File) # MS runs runs ## [1] 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw ## [2] 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_02.raw ## [3] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw ## [4] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_02.raw ## [5] 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_02.raw ## [6] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_01.raw ## [7] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_02.raw ## [8] 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_03.raw ## [9] 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_02.raw ## [10] 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_01.raw ## [11] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_03.raw ## [12] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_03.raw ## [13] 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_01.raw ## [14] 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_03.raw ## [15] 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_01.raw ## 15 Levels: 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw ... The run ID has the mixture and technical replicate information Let’s try to extract the mixture and technical replicate information. library(tidyr) library(dplyr) Run_info &lt;- data.frame(Run = runs) # initialize the run file # use function separate() ?separate ## Add the mixture and technical replicate information Run_info &lt;- Run_info %&gt;% separate(Run, c(&quot;Mixture&quot;, &quot;TechRepMixture&quot;), sep=&quot;_0&quot;, remove = FALSE) Run_info ## Run ## 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw ## 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_02.raw ## 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw ## 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_02.raw ## 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_02.raw ## 6 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_01.raw ## 7 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_02.raw ## 8 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_03.raw ## 9 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_02.raw ## 10 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_01.raw ## 11 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_03.raw ## 12 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_03.raw ## 13 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_01.raw ## 14 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_03.raw ## 15 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_01.raw ## Mixture TechRepMixture ## 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture3 3.raw ## 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture4 2.raw ## 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture1 1.raw ## 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture5 2.raw ## 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture2 2.raw ## 6 161117_SILAC_HeLa_UPS1_TMT10_Mixture5 1.raw ## 7 161117_SILAC_HeLa_UPS1_TMT10_Mixture1 2.raw ## 8 161117_SILAC_HeLa_UPS1_TMT10_Mixture4 3.raw ## 9 161117_SILAC_HeLa_UPS1_TMT10_Mixture3 2.raw ## 10 161117_SILAC_HeLa_UPS1_TMT10_Mixture3 1.raw ## 11 161117_SILAC_HeLa_UPS1_TMT10_Mixture5 3.raw ## 12 161117_SILAC_HeLa_UPS1_TMT10_Mixture1 3.raw ## 13 161117_SILAC_HeLa_UPS1_TMT10_Mixture4 1.raw ## 14 161117_SILAC_HeLa_UPS1_TMT10_Mixture2 3.raw ## 15 161117_SILAC_HeLa_UPS1_TMT10_Mixture2 1.raw Then let’s clean the Mixture ID and TechRepMixture ID ## clean the run file and add fraction information Run_info &lt;- Run_info %&gt;% mutate(Mixture = gsub(&quot;161117_SILAC_HeLa_UPS1_TMT10_&quot;, &quot;&quot;, Mixture), TechRepMixture = gsub(&quot;.raw&quot;, &quot;&quot;, TechRepMixture), Fraction = &quot;F1&quot;) Run_info ## Run Mixture TechRepMixture ## 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_02.raw Mixture4 2 ## 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw Mixture1 1 ## 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_02.raw Mixture5 2 ## 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_02.raw Mixture2 2 ## 6 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_01.raw Mixture5 1 ## 7 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_02.raw Mixture1 2 ## 8 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_03.raw Mixture4 3 ## 9 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_02.raw Mixture3 2 ## 10 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_01.raw Mixture3 1 ## 11 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_03.raw Mixture5 3 ## 12 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_03.raw Mixture1 3 ## 13 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_01.raw Mixture4 1 ## 14 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_03.raw Mixture2 3 ## 15 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_01.raw Mixture2 1 ## Fraction ## 1 F1 ## 2 F1 ## 3 F1 ## 4 F1 ## 5 F1 ## 6 F1 ## 7 F1 ## 8 F1 ## 9 F1 ## 10 F1 ## 11 F1 ## 12 F1 ## 13 F1 ## 14 F1 ## 15 F1 3.1.5.2.2 Prepare the file with group information Let’s add the group and biological replicate information for each channel in each mixture. The channel ID should be consistent with the reporter ion intensity columns in the PSM file of Proteome Discoverer. colnames(raw.pd) ## [1] &quot;Checked&quot; &quot;Confidence&quot; ## [3] &quot;Identifying.Node&quot; &quot;PSM.Ambiguity&quot; ## [5] &quot;Annotated.Sequence&quot; &quot;Modifications&quot; ## [7] &quot;Marked.as&quot; &quot;X..Protein.Groups&quot; ## [9] &quot;X..Proteins&quot; &quot;Master.Protein.Accessions&quot; ## [11] &quot;Master.Protein.Descriptions&quot; &quot;Protein.Accessions&quot; ## [13] &quot;Protein.Descriptions&quot; &quot;X..Missed.Cleavages&quot; ## [15] &quot;Charge&quot; &quot;DeltaScore&quot; ## [17] &quot;DeltaCn&quot; &quot;Rank&quot; ## [19] &quot;Search.Engine.Rank&quot; &quot;m.z..Da.&quot; ## [21] &quot;MH...Da.&quot; &quot;Theo..MH...Da.&quot; ## [23] &quot;DeltaM..ppm.&quot; &quot;Deltam.z..Da.&quot; ## [25] &quot;Activation.Type&quot; &quot;MS.Order&quot; ## [27] &quot;Isolation.Interference....&quot; &quot;Average.Reporter.S.N&quot; ## [29] &quot;Ion.Inject.Time..ms.&quot; &quot;RT..min.&quot; ## [31] &quot;First.Scan&quot; &quot;Spectrum.File&quot; ## [33] &quot;File.ID&quot; &quot;Abundance..126&quot; ## [35] &quot;Abundance..127N&quot; &quot;Abundance..127C&quot; ## [37] &quot;Abundance..128N&quot; &quot;Abundance..128C&quot; ## [39] &quot;Abundance..129N&quot; &quot;Abundance..129C&quot; ## [41] &quot;Abundance..130N&quot; &quot;Abundance..130C&quot; ## [43] &quot;Abundance..131&quot; &quot;Quan.Info&quot; ## [45] &quot;Ions.Score&quot; &quot;Identity.Strict&quot; ## [47] &quot;Identity.Relaxed&quot; &quot;Expectation.Value&quot; ## [49] &quot;Percolator.q.Value&quot; &quot;Percolator.PEP&quot; ## Channel ID in the PSM file channels &lt;- c(&quot;126&quot;, &quot;127N&quot;, &quot;127C&quot;, &quot;128N&quot;, &quot;128C&quot;, &quot;129N&quot;, &quot;129C&quot;, &quot;130N&quot;, &quot;130C&quot;, &quot;131&quot;) ## Mixture ID from run file mixtures &lt;- unique(Run_info$Mixture) mixtures ## [1] &quot;Mixture3&quot; &quot;Mixture4&quot; &quot;Mixture1&quot; &quot;Mixture5&quot; &quot;Mixture2&quot; ## create the file with channel information in each mixture Group_info &lt;- expand.grid(channels, mixtures) colnames(Group_info) &lt;- c(&quot;Channel&quot;, &quot;Mixture&quot;) head(Group_info) ## Channel Mixture ## 1 126 Mixture3 ## 2 127N Mixture3 ## 3 127C Mixture3 ## 4 128N Mixture3 ## 5 128C Mixture3 ## 6 129N Mixture3 ## save the channel file and fill in the condition and biological replicate information manually write.csv(Group_info, file = &quot;Group_info.csv&quot;, row.names = FALSE) ## Now the condition information should be available in the file Group_info_filled &lt;- read.csv(file = &quot;data/data_ProteomeDiscoverer_TMT/Group_info_pd.csv&quot;) head(Group_info_filled) ## Channel Mixture Condition BioReplicate ## 1 126 Mixture3 Norm Norm ## 2 127N Mixture3 0.125 0.125 ## 3 127C Mixture3 0.667 0.667 ## 4 128N Mixture3 1 1 ## 5 128C Mixture3 0.5 0.5 ## 6 129N Mixture3 0.5 0.5 3.1.5.2.3 Prepare the final annotation file Let’s generate the annotation file from run file and group file annotation &lt;- full_join(Run_info, Group_info_filled) ## Joining, by = &quot;Mixture&quot; ## Warning: Column `Mixture` joining character vector and factor, coercing ## into character vector nrow(annotation) ## [1] 150 head(annotation) ## Run Mixture TechRepMixture ## 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## 6 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw Mixture3 3 ## Fraction Channel Condition BioReplicate ## 1 F1 126 Norm Norm ## 2 F1 127N 0.125 0.125 ## 3 F1 127C 0.667 0.667 ## 4 F1 128N 1 1 ## 5 F1 128C 0.5 0.5 ## 6 F1 129N 0.5 0.5 3.1.5.3 Preprocessing with PDtoMSstatsTMTFormat The input data for MSstatsTMT is required to contain variables of ProteinName, PeptideSequence, Charge, PSM, Channel, Condition, BioReplicate, TechRepMixture, Mixture, Intensity. These variable names should be fixed. Output from Proteome Discoverer have different columns from the required input of MSstatsTMT. PDtoMSstatsTMTFormat function helps pre-processing for making right format of MSstatsTMT input from Proteome Discoverer output. For example, it renames some column name, and remove shared peptides. Here is the summary of pre-processing steps in PDtoMSstatsTMTFormat function. Peptide ions which are shared by more than one protein are removed If one spectrum has multiple identifications within one run, it only keeps the best identification which has most measurements within that run or highest identification score or largest summation of all the measurements within that run If one peptide ion has any missing value within one run, it removes the peptide ion from that run For fractionation, it removes the shared peptide ions among the fractions of each mixture and then combine all the fractions for each mixture For further details, visit the help file using the following code. ?PDtoMSstatsTMTFormat # reformating and pre-processing for PD output. input.pd &lt;- PDtoMSstatsTMTFormat(raw.pd, annotation=annotation) head(input.pd) ## ProteinName PeptideSequence Charge ## 1 P05413ups [K].lGVEFDETTADDRk.[V] 3 ## 2 Q92734 [K].nVMSAFGLTDDQVSGPPSAPAEDr.[S] 3 ## 3 P02787ups [K].eGYYGYTGAFR.[C] 2 ## 4 Q9HAV4 [K].tDSPScEYSr.[F] 2 ## 5 P13667 [K].eENGVLVLNDANFDNFVADk.[D] 3 ## 6 P10155 [K].aLSVETEk.[L] 2 ## PSM Mixture TechRepMixture ## 1 [K].lGVEFDETTADDRk.[V]_3 Mixture1 1 ## 2 [K].nVMSAFGLTDDQVSGPPSAPAEDr.[S]_3 Mixture1 1 ## 3 [K].eGYYGYTGAFR.[C]_2 Mixture1 1 ## 4 [K].tDSPScEYSr.[F]_2 Mixture1 1 ## 5 [K].eENGVLVLNDANFDNFVADk.[D]_3 Mixture1 1 ## 6 [K].aLSVETEk.[L]_2 Mixture1 1 ## Run Channel Condition ## 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## 6 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw 126 Norm ## BioReplicate Intensity ## 1 Norm 34115.190 ## 2 Norm 11431.716 ## 3 Norm 25847.839 ## 4 Norm 2446.339 ## 5 Norm 26508.569 ## 6 Norm 20478.670 3.1.5.4 Preliminary check # total number of proteins proteins &lt;- unique(input.pd$ProteinName) length(proteins) ## [1] 50 # show the spiked-in proteins proteins[grepl(&quot;ups&quot;,proteins)] ## [1] P05413ups P02787ups P00915ups P02788ups P01344ups ## [6] P01375ups P01031ups P01008ups P68871ups P02753ups ## [11] P10636-8ups P62988ups P02741ups P01579ups P02144ups ## 50 Levels: A1L0T0 O00625 O60427 P00915ups P01008ups ... Q9Y6C9 3.1.5.5 Save your work We can save the data that we made so far. save(input.pd, file=&#39;data/data_ProteomeDiscoverer_TMT/input.pd.rda&#39;) #write.csv(input.pd, file=&#39;data/data_ProteomeDiscoverer_TMT/input.pd.csv&#39;, row.names = FALSE) 3.1.6 MaxQuant output 3.1.6.1 Read data Three files should be prepared before MSstatsTMT. Two files, ‘proteinGroups.txt’ and ‘evidence.txt’ are outputs from MaxQuant. # First, get protein ID information proteinGroups &lt;- read.table(&quot;data/data_MaxQuant_TMT/proteinGroups.txt&quot;, sep = &quot;\\t&quot;, header = TRUE) # Read in MaxQuant file: evidence.txt evi &lt;- read.table(&quot;data/data_MaxQuant_TMT/evidence.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) colnames(evi) ## [1] &quot;Sequence&quot; ## [2] &quot;Length&quot; ## [3] &quot;Modifications&quot; ## [4] &quot;Modified.sequence&quot; ## [5] &quot;Arg10.Probabilities&quot; ## [6] &quot;Lys8.Probabilities&quot; ## [7] &quot;Lys8.TMT6.Probabilities&quot; ## [8] &quot;Oxidation..M..Probabilities&quot; ## [9] &quot;Arg10.Score.Diffs&quot; ## [10] &quot;Lys8.Score.Diffs&quot; ## [11] &quot;Lys8.TMT6.Score.Diffs&quot; ## [12] &quot;Oxidation..M..Score.Diffs&quot; ## [13] &quot;Arg10&quot; ## [14] &quot;Lys8&quot; ## [15] &quot;Lys8.TMT6&quot; ## [16] &quot;Oxidation..M.&quot; ## [17] &quot;Missed.cleavages&quot; ## [18] &quot;Proteins&quot; ## [19] &quot;Leading.proteins&quot; ## [20] &quot;Leading.razor.protein&quot; ## [21] &quot;Gene.names&quot; ## [22] &quot;Protein.names&quot; ## [23] &quot;Type&quot; ## [24] &quot;Raw.file&quot; ## [25] &quot;Experiment&quot; ## [26] &quot;MS.MS.m.z&quot; ## [27] &quot;Charge&quot; ## [28] &quot;m.z&quot; ## [29] &quot;Mass&quot; ## [30] &quot;Resolution&quot; ## [31] &quot;Uncalibrated...Calibrated.m.z..ppm.&quot; ## [32] &quot;Uncalibrated...Calibrated.m.z..Da.&quot; ## [33] &quot;Mass.Error..ppm.&quot; ## [34] &quot;Mass.Error..Da.&quot; ## [35] &quot;Uncalibrated.Mass.Error..ppm.&quot; ## [36] &quot;Uncalibrated.Mass.Error..Da.&quot; ## [37] &quot;Max.intensity.m.z.0&quot; ## [38] &quot;Retention.time&quot; ## [39] &quot;Retention.length&quot; ## [40] &quot;Calibrated.retention.time&quot; ## [41] &quot;Calibrated.retention.time.start&quot; ## [42] &quot;Calibrated.retention.time.finish&quot; ## [43] &quot;Retention.time.calibration&quot; ## [44] &quot;Match.time.difference&quot; ## [45] &quot;Match.m.z.difference&quot; ## [46] &quot;Match.q.value&quot; ## [47] &quot;Match.score&quot; ## [48] &quot;Number.of.data.points&quot; ## [49] &quot;Number.of.scans&quot; ## [50] &quot;Number.of.isotopic.peaks&quot; ## [51] &quot;PIF&quot; ## [52] &quot;Fraction.of.total.spectrum&quot; ## [53] &quot;Base.peak.fraction&quot; ## [54] &quot;PEP&quot; ## [55] &quot;MS.MS.Count&quot; ## [56] &quot;MS.MS.Scan.Number&quot; ## [57] &quot;Score&quot; ## [58] &quot;Delta.score&quot; ## [59] &quot;Combinatorics&quot; ## [60] &quot;Intensity&quot; ## [61] &quot;Reporter.intensity.corrected.0&quot; ## [62] &quot;Reporter.intensity.corrected.1&quot; ## [63] &quot;Reporter.intensity.corrected.2&quot; ## [64] &quot;Reporter.intensity.corrected.3&quot; ## [65] &quot;Reporter.intensity.corrected.4&quot; ## [66] &quot;Reporter.intensity.corrected.5&quot; ## [67] &quot;Reporter.intensity.corrected.6&quot; ## [68] &quot;Reporter.intensity.corrected.7&quot; ## [69] &quot;Reporter.intensity.corrected.8&quot; ## [70] &quot;Reporter.intensity.corrected.9&quot; ## [71] &quot;Reporter.intensity.0&quot; ## [72] &quot;Reporter.intensity.1&quot; ## [73] &quot;Reporter.intensity.2&quot; ## [74] &quot;Reporter.intensity.3&quot; ## [75] &quot;Reporter.intensity.4&quot; ## [76] &quot;Reporter.intensity.5&quot; ## [77] &quot;Reporter.intensity.6&quot; ## [78] &quot;Reporter.intensity.7&quot; ## [79] &quot;Reporter.intensity.8&quot; ## [80] &quot;Reporter.intensity.9&quot; ## [81] &quot;Reporter.intensity.count.0&quot; ## [82] &quot;Reporter.intensity.count.1&quot; ## [83] &quot;Reporter.intensity.count.2&quot; ## [84] &quot;Reporter.intensity.count.3&quot; ## [85] &quot;Reporter.intensity.count.4&quot; ## [86] &quot;Reporter.intensity.count.5&quot; ## [87] &quot;Reporter.intensity.count.6&quot; ## [88] &quot;Reporter.intensity.count.7&quot; ## [89] &quot;Reporter.intensity.count.8&quot; ## [90] &quot;Reporter.intensity.count.9&quot; ## [91] &quot;Reporter.PIF&quot; ## [92] &quot;Reporter.fraction&quot; ## [93] &quot;Reverse&quot; ## [94] &quot;Potential.contaminant&quot; ## [95] &quot;id&quot; ## [96] &quot;Protein.group.IDs&quot; ## [97] &quot;Peptide.ID&quot; ## [98] &quot;Mod..peptide.ID&quot; ## [99] &quot;MS.MS.IDs&quot; ## [100] &quot;Best.MS.MS&quot; ## [101] &quot;AIF.MS.MS.IDs&quot; ## [102] &quot;Arg10.site.IDs&quot; ## [103] &quot;Lys8.site.IDs&quot; ## [104] &quot;Lys8.TMT6.site.IDs&quot; ## [105] &quot;Oxidation..M..site.IDs&quot; unique(evi$Raw.file) ## [1] 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_01 ## [2] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_01 ## [3] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_02 ## [4] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_03 ## [5] 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_03 ## [6] 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_02 ## [7] 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03 ## [8] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 ## [9] 161117_SILAC_HeLa_UPS1_TMT10_Mixture3_01 ## [10] 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_01 ## [11] 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_02 ## [12] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_02 ## [13] 161117_SILAC_HeLa_UPS1_TMT10_Mixture2_02 ## [14] 161117_SILAC_HeLa_UPS1_TMT10_Mixture4_03 ## [15] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_03 ## 15 Levels: 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 ... Again, we need file annotation file, required to fill in Condition, BioReplicate and Mixture for corresponding Run and Channel information. Users have to prepare as csv or txt file like ‘MaxQuant_annotation.csv’, which includes Run, Channel, Condition, BioReplicate, TechRepMixture and Mixture information, and load it in R. 3.1.6.2 Set annotation file Run column in the annotation file should be the same as unique Raw.file in evidence.txt file. Channel column in the annotation file should match with the corresponding channel names in evidence.txt file. # Read in annotation including condition and biological replicates: MaxQuant_annotation.csv annot.maxquant &lt;- read.csv(&quot;data/data_MaxQuant_TMT/MaxQuant_annotation.csv&quot;, header = TRUE) head(annot.maxquant) ## Run Fraction TechRepMixture ## 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 1 1 ## 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 1 1 ## 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 1 1 ## 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 1 1 ## 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 1 1 ## 6 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 1 1 ## Channel Condition Mixture BioReplicate ## 1 channel.0 Norm Mixture1 Norm ## 2 channel.1 0.667 Mixture1 0.667 ## 3 channel.2 0.125 Mixture1 0.125 ## 4 channel.3 0.5 Mixture1 0.5 ## 5 channel.4 1 Mixture1 1 ## 6 channel.5 0.125 Mixture1 0.125 3.1.6.3 Preprocessing with MaxQtoMSstatsTMTFormat MaxQtoMSstatsTMTFormat function helps pre-processing for making right format of MSstatsTMT input from MaxQuant output. Basically, this function gets peptide ion intensity from ‘evidence.txt’ file. In addition, there are several steps to filter out or to modify the data in order to get required information. Here is the summary of pre-processing steps in MaxQtoMSstatsTMTFormat function Use Proteins in ‘proteinGroups.txt’ as protein ID Peptide ions which are shared by more than one protein are removed If one spectrum has multiple identifications within one run, it only keeps the best identification which has most measurements within that run or highest identification score or largest summation of all the measurements within that run If one peptide ion has any missing value within one run, it removes the peptide ion from that run For fractionation, it removes the shared peptide ions among the fractions of each mixture and then combine all the fractions for each mixture ?MaxQtoMSstatsTMTFormat # reformating and pre-processing for MaxQuant output. input.maxquant &lt;- MaxQtoMSstatsTMTFormat(evidence=evi, annotation=annot.maxquant, proteinGroups=proteinGroups) head(input.maxquant) ## ProteinName PeptideSequence Charge ## 1 P67870 VYCENQPMLPIGLSDIPGEAMVK(ly) 3 ## 2 Q9HAV4 TDSPSCEYSR(ar) 2 ## 3 P62988ups GSHMQIFVK 3 ## 4 Q9HAV4 EVMDLITVCCVSK(ly) 3 ## 5 P13667 DFPEYTFAIADEEDYAGEVK(ly) 3 ## 6 O00625 NLDPFLLFDEFK(ly) 2 ## PSM Mixture TechRepMixture ## 1 VYCENQPMLPIGLSDIPGEAMVK(ly)_3 Mixture1 1 ## 2 TDSPSCEYSR(ar)_2 Mixture1 1 ## 3 GSHMQIFVK_3 Mixture1 1 ## 4 EVMDLITVCCVSK(ly)_3 Mixture1 1 ## 5 DFPEYTFAIADEEDYAGEVK(ly)_3 Mixture1 1 ## 6 NLDPFLLFDEFK(ly)_2 Mixture1 1 ## Run Channel BioReplicate ## 1 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 channel.0 Norm ## 2 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 channel.0 Norm ## 3 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 channel.0 Norm ## 4 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 channel.0 Norm ## 5 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 channel.0 Norm ## 6 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01 channel.0 Norm ## Condition Intensity ## 1 Norm 970.35 ## 2 Norm 405.15 ## 3 Norm 2276.00 ## 4 Norm 1341.60 ## 5 Norm 1092.30 ## 6 Norm 2546.50 3.1.6.4 Preliminary check # total number of proteins proteins &lt;- unique(input.maxquant$ProteinName) length(proteins) ## [1] 33 # show the spiked-in proteins proteins[grepl(&quot;ups&quot;,proteins)] ## [1] P62988ups P62937ups ## 39 Levels: A1L0T0 O00625 O60427 P01127ups P01344ups P04183 ... Q9Y6C9 3.1.6.5 Save your work We can save the data that we made so far. save(input.maxquant, file=&#39;data/data_MaxQuant_TMT/input.maxquant.rda&#39;) 3.2 Summarization, normalization and significance analysis 3.2.1 Objective Channel-level summarization and normalization between runs Significance analysis for MS proteomics based peak intensities data 3.2.2 Data The pre-processed data input.pd.rda from section 4. 3.2.3 Process with processed PD data Let’s start processing steps. It includes log transformation of intensities, channel-level summarization and normalization between MS runs. 3.2.3.1 Load the pre-processed data of PD output load(file=&#39;data/data_ProteomeDiscoverer_TMT/input.pd.rda&#39;) 3.2.4 Normalizing and summarizing data with proteinSummarization ! Always pay attention to the default options After reading the datasets, MSstatsTMT performs logarithm transformation of Intensity column channel-level summarization run-to-run normalization for each protein based on reference channel To get started with this function, visit the help section of proteinSummarization first: ?proteinSummarization 3.2.4.1 Default summarization and normalization options proteinSummarization perform first (1) channel level summarization will be performed, which is robust parameter estimation by TMP (Tukey’s median polish). Then, (2) normalization between MS runs. TRUE(default) needs at least one normalization channel in each MS run, annotated by ‘Norm’ in Condition column. If there are multiple normalization channels, all the normalization channels are averaged for the normalization. FALSE will not perform normalization step. Below show the default for all options in proteinSummarization quant.pd &lt;- proteinSummarization(data = input.pd, method = &quot;msstats&quot;, normalization = TRUE) save(quant.pd, file=&#39;data/data_ProteomeDiscoverer_TMT/quant.pd.rda&#39;) Let’s check output from proteinSummarization. # This table includes normalized channel-level log2 intensities. (column : Abundance) # Now one summarized log2 intensities per Protein, Run, Channel. head(quant.pd) ## Run Protein Abundance Channel ## 1: 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw A1L0T0 12.26466 127C ## 2: 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw A1L0T0 12.20385 129N ## 3: 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw A1L0T0 12.47977 128N ## 4: 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw A1L0T0 12.25433 129C ## 5: 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw A1L0T0 12.05181 127N ## 6: 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw A1L0T0 12.11299 130C ## BioReplicate Condition TechRepMixture Mixture ## 1: 0.125 0.125 1 Mixture1 ## 2: 0.125 0.125 1 Mixture1 ## 3: 0.5 0.5 1 Mixture1 ## 4: 0.5 0.5 1 Mixture1 ## 5: 0.667 0.667 1 Mixture1 ## 6: 0.667 0.667 1 Mixture1 3.2.5 Visualization of processed data 3.2.5.1 Profile plots Profile plot is good visualization to check individual measurements. Each dot means one intensity per Run per Channel. Each panel represents one MS run and each dot within one panel is one channel within one Run. The dots are linked with line per feature. If line is disconnected, that means there is no value (missing value). Color means different peptides and charge stages. # if you have many MS runs, adjust width of plot (make wider) # Profile plot for the normalized data dataProcessPlotsTMT(data.psm=input.pd, # PSM-level data data.summarization=quant.pd, # protein-level data type=&#39;ProfilePlot&#39;, # choice of visualization width = 15, height = 5, address=&quot;data/data_ProteomeDiscoverer_TMT/pd_norm_&quot;) pd_norm_ProfilePlot.pdf and pd_norm_ProfilePlot_wSummarization.pdf are generated in the current directory. Then, Let’s go though profile plots to see overall quality of data. There are two pdfs for each protein, first is profile plot and second plot is profile plot with summarized and normalized data. This profile plot shows each peptide ions across runs and channels, grouped per condition. Each peptide has a different colour/type layout. This plot shows the same peptide ions in grey, with the values as summarized by the model overlayed in red. Instead of making all profile plots for all proteins, we can make plot for individual protein. Here is the example of background protein, P35221 dataProcessPlotsTMT(data.psm=input.pd, # PSM-level data data.summarization=quant.pd, # protein-level data type=&#39;ProfilePlot&#39;, # choice of visualization width = 15, height = 5, which.Protein = &#39;P35221&#39;, address=&quot;data/data_ProteomeDiscoverer_TMT/pd_norm_P35221_&quot;) 3.2.5.2 Quality control plots QC plot is good to see the distribution of peptide intensities per MS run and channels, and outliers. # QC plot for peptide intensity data dataProcessPlotsTMT(data.psm=input.pd, # PSM-level data data.summarization=quant.pd, # protein-level data type=&#39;QCPlot&#39;, # choice of visualization width = 15, height = 5, address=&quot;data/data_ProteomeDiscoverer_TMT/pd_&quot;) Then, pd_QCPlot.pdf are generated in the current directory. Challenge This is the study design. Let’s check visualization for other 3 proteins. 1. P02788ups 2. P02787ups 3. P26639 3.2.6 Different parameter options for summarization and normalization 3.2.6.1 No normalization No normalization is performed. If you don’t want to do run-to-run normalization, you should use like below. quant.pd.nonorm &lt;-proteinSummarization(data = input.pd, method = &quot;msstats&quot;, normalization = FALSE) dataProcessPlotsTMT(data.psm = input.pd, # PSM-level data data.summarization = quant.pd.nonorm, # protein-level data type = &#39;ProfilePlot&#39;, # choice of visualization width = 15, height = 5, originalPlot = FALSE, which.Protein = &#39;P35221&#39;, address=&quot;data/data_ProteomeDiscoverer_TMT/pd_noNorm_P35221_&quot;) 3.2.6.2 Different summarization option MSstatsTMT provides five different summarization methods for protein quantification. msstats is default, which we have used before. Now let’s try another robust summarization method Median. quant.pd.median &lt;-proteinSummarization(data = input.pd, method = &quot;Median&quot;, normalization = TRUE) Run summarization is different. dataProcessPlotsTMT(data.psm=input.pd, # PSM-level data data.summarization=quant.pd.median, # protein-level data type=&#39;ProfilePlot&#39;, # choice of visualization width = 15, height = 5, originalPlot = FALSE, which.Protein = &#39;P35221&#39;, address=&quot;data/data_ProteomeDiscoverer_TMT/pd_median_P35221_&quot;) 3.2.7 Finding differentially abundant proteins across conditions 3.2.7.1 Assign contrast matrix After we summarized each protein’s behavior across conditions and normalized the data between runs in proteinSummarization step, we are all set to compare protein changes between groups of conditions. Within MSstatsTMT we can do this with the groupComparisonTMT function, which takes as input the output of the proteinSummarization function. ?groupComparisonTMT We have to tell groupComparisonTMT which are the conditions we would like to compare. You can make your contrast.matrix in R in a text editor. We define our contrast matrix by adding a column for every condition. We add a row for every comparison we would like to make between groups of conditions. 0 is for conditions we would like to ignore. 1 is for conditions we would like to put in the numerator of the ratio or fold-change. -1 is for conditions we would like to put in the denumerator of the ratio or fold-change. If you have multiple groups, you can assign any group comparisons you are interested in. # check unique conditions and check order of condition information # In this case, four different concentrations unique(quant.pd$Condition) ## [1] 0.125 0.5 0.667 1 Norm ## Levels: 0.125 0.5 0.667 1 Norm # &#39;Norm&#39; will be removed during tesing and should be not considered in the contrast comparison1&lt;-matrix(c(-1,0,0,1),nrow=1) # 0.5-0.125 comparison2&lt;-matrix(c(0,-1,1,0),nrow=1) # 0.667-0.5 comparison&lt;-rbind(comparison1, comparison2) # Set the column names colnames(comparison)&lt;- c(&quot;0.125&quot;, &quot;0.5&quot;, &quot;0.667&quot;, &quot;1&quot;) # Set the names of each row row.names(comparison)&lt;-c(&quot;1-0.125&quot;,&quot;0.667-0.5&quot;) comparison ## 0.125 0.5 0.667 1 ## 1-0.125 -1 0 0 1 ## 0.667-0.5 0 -1 1 0 Challenges Make the matrix, named comparison, for all 6 paired comparision among 4 conditions (condition1, condition2, condition3, condition4) unique(quant.pd$Condition) ## [1] 0.125 0.5 0.667 1 Norm ## Levels: 0.125 0.5 0.667 1 Norm comparison1&lt;-matrix(c(-1,1,0,0),nrow=1) comparison2&lt;-matrix(c(-1,0,1,0),nrow=1) comparison3&lt;-matrix(c(-1,0,0,1),nrow=1) comparison4&lt;-matrix(c(0,-1,1,0),nrow=1) comparison5&lt;-matrix(c(0,-1,0,1),nrow=1) comparison6&lt;-matrix(c(0,0,-1,1),nrow=1) comparison_all&lt;-rbind(comparison1, comparison2, comparison3, comparison4, comparison5, comparison6) # Set the column names colnames(comparison_all)&lt;- c(&quot;0.125&quot;, &quot;0.5&quot;, &quot;0.667&quot;, &quot;1&quot;) # Set the names of each row row.names(comparison_all)&lt;-c(&quot;0.5-0.125&quot;,&quot;0.667-0.125&quot;,&quot;1-0.125&quot;,&quot;0.667-0.5&quot;,&quot;1-0.5&quot;,&quot;1-0.667&quot;) comparison_all ## 0.125 0.5 0.667 1 ## 0.5-0.125 -1 1 0 0 ## 0.667-0.125 -1 0 1 0 ## 1-0.125 -1 0 0 1 ## 0.667-0.5 0 -1 1 0 ## 1-0.5 0 -1 0 1 ## 1-0.667 0 0 -1 1 3.2.7.2 Group comparisons with groupComparisonTMT groupComparisonTMT uses the channel-level summarized data for hypothesis testing. test.pd &lt;- groupComparisonTMT(data = quant.pd, contrast.matrix = comparison, remove_norm_channel = TRUE, # remove norm channels moderated = TRUE, # do moderated t test adj.method = &quot;BH&quot;) # multiple comparison adjustment Let’s check the output. colnames(test.pd) ## [1] &quot;Protein&quot; &quot;Label&quot; &quot;log2FC&quot; &quot;SE&quot; &quot;DF&quot; ## [6] &quot;pvalue&quot; &quot;adj.pvalue&quot; # Show test result # Label : which comparison is used # log2FC : estimated log2 fold change between two conditions (the contrast) # adj.pvalue : adjusted p value head(test.pd) ## Protein Label log2FC SE DF pvalue adj.pvalue ## 1 A1L0T0 1-0.125 0.07999809 0.04407490 105.9517 0.07234539 0.2127806 ## 2 A1L0T0 0.667-0.5 -0.04897305 0.04407490 105.9517 0.26902646 0.4352093 ## 3 O00625 1-0.125 0.02751219 0.01930260 105.9517 0.15700684 0.3568337 ## 4 O00625 0.667-0.5 -0.02494449 0.01930260 105.9517 0.19906924 0.3981385 ## 5 O60427 1-0.125 0.04234680 0.02688754 105.9517 0.11824700 0.3284639 ## 6 O60427 0.667-0.5 0.01193862 0.02688754 105.9517 0.65793338 0.8023578 3.2.7.3 Save the comparison result Let’s save the testing result as .csv file. save(test.pd, file=&#39;data/data_ProteomeDiscoverer_TMT/pd.result.rda&#39;) write.csv(test.pd, file=&#39;data/data_ProteomeDiscoverer_TMT/testResult_pd.csv&#39;) 3.2.7.4 Significant tests Let’s inspect the results to see what proteins are changing significantly between two concentrations. head(test.pd) ## Protein Label log2FC SE DF pvalue adj.pvalue ## 1 A1L0T0 1-0.125 0.07999809 0.04407490 105.9517 0.07234539 0.2127806 ## 2 A1L0T0 0.667-0.5 -0.04897305 0.04407490 105.9517 0.26902646 0.4352093 ## 3 O00625 1-0.125 0.02751219 0.01930260 105.9517 0.15700684 0.3568337 ## 4 O00625 0.667-0.5 -0.02494449 0.01930260 105.9517 0.19906924 0.3981385 ## 5 O60427 1-0.125 0.04234680 0.02688754 105.9517 0.11824700 0.3284639 ## 6 O60427 0.667-0.5 0.01193862 0.02688754 105.9517 0.65793338 0.8023578 # select subset of rows with adj.pvalue &lt; 0.05 SignificantProteins &lt;- test.pd[test.pd$adj.pvalue &lt;= 0.05 ,] SignificantProteins ## Protein Label log2FC SE DF pvalue ## 7 P00915ups 1-0.125 1.9194954 0.05722839 84.95168 8.945464e-51 ## 8 P00915ups 0.667-0.5 0.2749177 0.05722839 84.95168 6.627634e-06 ## 9 P01008ups 1-0.125 2.1144893 0.06806652 84.95168 3.713705e-48 ## 10 P01008ups 0.667-0.5 0.2896649 0.06806652 84.95168 5.344220e-05 ## 11 P01031ups 1-0.125 1.8041566 0.11087020 68.95168 2.618058e-25 ## 12 P01031ups 0.667-0.5 0.4107830 0.10542938 68.95168 2.234092e-04 ## 13 P01344ups 1-0.125 2.0688076 0.06904749 91.95168 3.130553e-49 ## 14 P01344ups 0.667-0.5 0.3713574 0.06904749 91.95168 5.682775e-07 ## 15 P01375ups 1-0.125 2.5243218 0.08825488 77.95168 4.360217e-43 ## 16 P01375ups 0.667-0.5 0.3386098 0.08825488 77.95168 2.517549e-04 ## 17 P01579ups 1-0.125 1.6369755 0.09944662 77.95168 4.355455e-27 ## 19 P02741ups 1-0.125 1.8161644 0.06738557 77.95168 2.947523e-41 ## 20 P02741ups 0.667-0.5 0.3161686 0.06738557 77.95168 1.135753e-05 ## 21 P02753ups 1-0.125 1.5937054 0.08948401 77.95168 3.355143e-29 ## 22 P02753ups 0.667-0.5 0.2909960 0.08948401 77.95168 1.694685e-03 ## 23 P02787ups 1-0.125 2.0540332 0.03904033 105.95168 9.144927e-78 ## 24 P02787ups 0.667-0.5 0.2987191 0.03904033 105.95168 9.649755e-12 ## 25 P02788ups 1-0.125 1.8663815 0.03138725 98.95168 2.995382e-79 ## 26 P02788ups 0.667-0.5 0.2883261 0.03138725 98.95168 6.544522e-15 ## 29 P05413ups 1-0.125 2.0644363 0.08101181 105.95168 5.372994e-47 ## 30 P05413ups 0.667-0.5 0.2541415 0.08101181 105.95168 2.209538e-03 ## 33 P10636-8ups 1-0.125 2.4076666 0.09799311 103.95168 4.284414e-45 ## 34 P10636-8ups 0.667-0.5 0.4545902 0.09628875 103.95168 7.354719e-06 ## 45 P62988ups 1-0.125 0.3426051 0.03193782 105.95168 1.286571e-18 ## 49 P68871ups 1-0.125 2.4318364 0.06435396 104.95168 6.249411e-63 ## 50 P68871ups 0.667-0.5 0.2824179 0.06380626 104.95168 2.355015e-05 ## 97 P02144ups 1-0.125 2.0888596 0.06699695 70.95168 3.779206e-43 ## 98 P02144ups 0.667-0.5 0.2559477 0.06699695 70.95168 2.828965e-04 ## adj.pvalue ## 7 1.118183e-49 ## 8 7.354719e-05 ## 9 3.094754e-47 ## 10 3.340138e-04 ## 11 9.350206e-25 ## 12 1.241162e-03 ## 13 3.130553e-48 ## 14 9.471292e-06 ## 15 2.180109e-42 ## 16 1.258775e-03 ## 17 1.675175e-26 ## 19 1.339783e-40 ## 20 9.464611e-05 ## 21 1.397976e-28 ## 22 7.061187e-03 ## 23 2.286232e-76 ## 24 2.412439e-10 ## 25 1.497691e-77 ## 26 3.272261e-13 ## 29 3.837853e-46 ## 30 8.498222e-03 ## 33 2.677759e-44 ## 34 7.354719e-05 ## 45 4.288570e-18 ## 49 1.041569e-61 ## 50 1.682154e-04 ## 97 2.099559e-42 ## 98 1.285893e-03 nrow(SignificantProteins) ## [1] 28 # select subset of rows with adj.pvalue &lt; 0.05 and absoluate log2FC &gt; 1 SignificantProteinsLargeFC &lt;- SignificantProteins[abs(SignificantProteins$log2FC) &gt; 1 ,] SignificantProteinsLargeFC ## Protein Label log2FC SE DF pvalue ## 7 P00915ups 1-0.125 1.919495 0.05722839 84.95168 8.945464e-51 ## 9 P01008ups 1-0.125 2.114489 0.06806652 84.95168 3.713705e-48 ## 11 P01031ups 1-0.125 1.804157 0.11087020 68.95168 2.618058e-25 ## 13 P01344ups 1-0.125 2.068808 0.06904749 91.95168 3.130553e-49 ## 15 P01375ups 1-0.125 2.524322 0.08825488 77.95168 4.360217e-43 ## 17 P01579ups 1-0.125 1.636975 0.09944662 77.95168 4.355455e-27 ## 19 P02741ups 1-0.125 1.816164 0.06738557 77.95168 2.947523e-41 ## 21 P02753ups 1-0.125 1.593705 0.08948401 77.95168 3.355143e-29 ## 23 P02787ups 1-0.125 2.054033 0.03904033 105.95168 9.144927e-78 ## 25 P02788ups 1-0.125 1.866381 0.03138725 98.95168 2.995382e-79 ## 29 P05413ups 1-0.125 2.064436 0.08101181 105.95168 5.372994e-47 ## 33 P10636-8ups 1-0.125 2.407667 0.09799311 103.95168 4.284414e-45 ## 49 P68871ups 1-0.125 2.431836 0.06435396 104.95168 6.249411e-63 ## 97 P02144ups 1-0.125 2.088860 0.06699695 70.95168 3.779206e-43 ## adj.pvalue ## 7 1.118183e-49 ## 9 3.094754e-47 ## 11 9.350206e-25 ## 13 3.130553e-48 ## 15 2.180109e-42 ## 17 1.675175e-26 ## 19 1.339783e-40 ## 21 1.397976e-28 ## 23 2.286232e-76 ## 25 1.497691e-77 ## 29 3.837853e-46 ## 33 2.677759e-44 ## 49 1.041569e-61 ## 97 2.099559e-42 3.2.7.5 Different parameter options for group comparison If you want to make all the pairwise comparison,MSstatsTMT has an easy option for it. Setting contrast.matrix = pairwise compares all the possible pairs between two conditions. test.pd.pairwise &lt;- groupComparisonTMT(data = quant.pd, contrast.matrix = &quot;pairwise&quot;, remove_norm_channel = TRUE, # remove norm channels moderated = TRUE, # do moderated t test adj.method = &quot;BH&quot;) # multiple comparison adjustment # show the comparisons unique(test.pd.pairwise$Label) ## [1] &quot;0.125-0.5&quot; &quot;0.125-0.667&quot; &quot;0.125-1&quot; &quot;0.5-0.667&quot; &quot;0.5-1&quot; ## [6] &quot;0.667-1&quot; 3.2.8 msstatstmt.log and sessionInfo.txt These two files are important to keep the records of package versions and options in functions. Challenges Try proteinSummarization with msstats summarization and between-runs normalization for MaxQuant output. (input.maxquant.rda from section 4) load(file=&#39;data/data_MaxQuant_TMT/input.maxquant.rda&#39;) quant.maxquant &lt;-proteinSummarization(data = input.maxquant, method = &quot;msstats&quot;, normalization = TRUE) Try proteinSummarization with msstats summarization and without normalization for MaxQuant output. (input.maxquant.rda from section 4) quant.maxquant.nonorm &lt;-proteinSummarization(data = input.maxquant, method = &quot;msstats&quot;, normalization = FALSE) Draw Profile plots of protein P26639, for both cases above and compare. dataProcessPlotsTMT(data.psm=input.maxquant, # PSM-level data data.summarization=quant.maxquant, # protein-level data type=&#39;ProfilePlot&#39;, # choice of visualization width = 15, height = 5, which.Protein = &#39;P26639&#39;, address=&quot;data/data_MaxQuant_TMT/maxquant_norm_P26639_&quot;) dataProcessPlotsTMT(data.psm=input.maxquant, # PSM-level data data.summarization=quant.maxquant.nonorm, # protein-level data type=&#39;ProfilePlot&#39;, # choice of visualization width = 15, height = 5, originalPlot = FALSE, which.Protein = &#39;P26639&#39;, address=&quot;data/data_MaxQuant_TMT/maxquant_nonorm_P26639_&quot;) From quant.maxquant data, find the differentially abundant comparisons using groupComparison with the same comparison matrix. test.maxquant &lt;- groupComparisonTMT(data = quant.maxquant, contrast.matrix = comparison) write.csv(test.maxquant, file=&#39;data/data_MaxQuant_TMT/testResult_maxquant.csv&#39;) "]
]
